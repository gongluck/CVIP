# 事务

- [事务](#事务)
  - [事务特性](#事务特性)
    - [原子性](#原子性)
    - [一致性](#一致性)
    - [隔离性](#隔离性)
    - [持久性](#持久性)
  - [隔离级别](#隔离级别)
    - [读未提交](#读未提交)
    - [读已提交](#读已提交)
    - [可重复读](#可重复读)
    - [可串行化](#可串行化)
  - [脏读](#脏读)
  - [不可重复读](#不可重复读)
  - [快照读](#快照读)
  - [当前读](#当前读)
  - [幻读](#幻读)

## 事务特性

### 原子性

- 事务中的所有操作要么全部成功执行，要么全部回滚
- 如果在事务执行过程中发生错误，会将已经执行的操作进行回滚，保持数据一致性

### 一致性

- 事务开始前和结束后，数据库的完整性约束没有被破坏
- 在事务执行过程中对数据的修改必须符合预定义的规则，以保证数据的有效性和正确性

### 隔离性

- 每个事务在并发执行时都应该相互隔离，并且不应该互相干扰
- 一个事务在提交之前对其他事务是不可见的，防止了读取到未提交或部分提交的数据

### 持久性

- 一旦事务提交成功后，其所做的修改就会永久保存到数据库中，并且不能被撤销
- 即使在系统故障或断电情况下，也能够保证数据不会丢失

## 隔离级别

### 读未提交

- 一个事务可以读取另一个事务尚未提交的数据
- 这可能导致脏读：一个事务读取了另一个事务尚未提交的数据。如果该事务回滚，读取到的数据将无效

### 读已提交

- 一个事务只能读取另一个事务已提交的数据
- 解决了脏读问题，但可能导致不可重复读：在一个事务中，多次读取同一数据，由于其他事务的修改，导致返回的数据不一致

### 可重复读

- 一个事务在其生命周期内多次读取同一数据，数据始终保持一致
- 解决了不可重复读问题，但可能导致幻读：在一个事务中，两次查询范围相同的记录，由于其他事务的插入或删除操作，导致返回的记录数量不一致

### 可串行化

- 事务被强制按顺序执行，完全避免了脏读、不可重复读和幻读等问题
- 牺牲了并发性能，因为事务必须按顺序执行

## 脏读

- 一个事务可以读到其它事务未提交的状态

## 不可重复读

- 一个事务中两次读的结果不同
- 因为读已提交是读最新版本的数据，最新的数据可能被其它事务修改

## 快照读

- 利用 MVCC 机制读取快照中的数据，提高了并发的性能，降低开销
- 不加锁的简单的 select 都属于快照读

## 当前读

- 当前读读取的是记录的最新版本，读取时会对读取的记录进行加锁, 其他事务就有可能阻塞
- 加锁的 select，或者对数据进行增删改都会进行当前读

## 幻读

- 一个事务中两次读取同一个范围的结果不同
- 在可重复读隔离级别下，普通的查询是快照读，是不会看到别的事务插入的数据的。因此，幻读在当前读 for update 下才会出现。当前读的规则，就是要能读到所有已经提交的记录的最新值
- 因为当前读和快照读不一致造成
- 针对快照读（普通 select 语句），是通过 MVCC 方式解决了幻读
- 针对当前读（select ... for update 等语句），是通过 next-key lock（记录锁+间隙锁）方式解决了幻读
