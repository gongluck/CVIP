# 内存

- [内存](#内存)
  - [地址转换](#地址转换)
  - [TLB](#tlb)
  - [DMA](#dma)
  - [缓存命中率](#缓存命中率)
  - [内存泄露](#内存泄露)
  - [性能分析](#性能分析)

## 地址转换

- 内存需要被分成固定大小的页，然后再通过虚拟内存地址到物理内存地址的地址转换，才能到达实际存放数据的物理内存位置。
- 程序看到的内存地址，都是虚拟内存地址，这些虚拟内存还需要通过页表，由系统映射为物理内存。
- 当进程通过 malloc() 申请虚拟内存后，系统并不会立即为其分配物理内存，而是在首次访问时，才通过缺页异常陷入内核中分配内存。
- 在内存资源紧张时，Linux 通过直接内存回收和定期扫描的方式，来释放文件页和匿名页，以便把内存分配给更需要的进程使用。

## TLB

![TLB](https://github.com/gongluck/images/blob/main/memory/tlb.png)

- 在 CPU 里放了一块缓存芯片，称之为 TLB，全称是地址变换高速缓冲(Translation-Lookaside Buffer)。
- 这块缓存存放了之前已经进行过地址转换的查询结果。当同样的虚拟地址需要进行地址转换的时候，可以直接在 TLB 里面查询结果，而不需要多次访问内存来完成一次转换。

## DMA

- DMA 技术，就是直接内存访问(Direct Memory Access)技术，来减少 CPU 等待的时间。
- 本质上，DMA 技术就是在主板上放一块独立的芯片。在进行内存和 I/O 设备的数据传输的时候，不再通过 CPU 来控制数据传输，而直接通过 DMA 控制器(DMA Controller，DMAC)。这块芯片其实就是一个协处理器(Co-Processor)。
- DMAC 最有价值的地方体现在，当要传输的数据特别大、速度特别快，或者传输的数据特别小、速度特别慢的时候。比如，用千兆网卡或者硬盘传输大量数据时，如果都用CPU来搬运的话，肯定忙不过来，所以可以选择DMAC。而当传输很慢的时候，DMAC可以等数据到齐了，再发送信号，给到CPU去处理，而不是让CPU在哪里忙等。

## 缓存命中率

- cachestat 提供了整个操作系统缓存的读写命中情况。
- cachetop 提供了每个进程的缓存命中情况。

## 内存泄露

- memleak 可以跟踪系统或指定进程的内存分配、释放请求，然后定期输出一个未释放内存和相应调用栈的汇总情况。

## 性能分析

![内存性能分析](https://github.com/gongluck/images/blob/main/linux/performance/memory.png)

- 最好禁止 Swap。如果必须开启 Swap，降低 swappiness 的值，减少内存回收时 Swap 的使用倾向。
- 减少内存的动态分配。比如，可以使用内存池、大页（HugePage）等。
- 尽量使用缓存和缓冲区来访问数据。比如，可以使用堆栈明确声明内存空间，来存储需要缓存的数据；或者用 Redis 这类的外部缓存组件，优化数据的访问。
- 使用 cgroups 等方式限制进程的内存使用情况。这样，可以确保系统内存不会被异常进程耗尽。
- 通过 /proc/pid/oom_adj ，调整核心应用的 oom_score。这样，可以保证即使内存紧张，核心应用也不会被 OOM 杀死。
