# 内存

- [内存](#内存)
  - [地址转换](#地址转换)
  - [TLB](#tlb)
  - [Buffers/Cache](#bufferscache)
  - [SWAP](#swap)
  - [NUMA](#numa)
  - [DMA](#dma)
  - [缓存命中率](#缓存命中率)
  - [内存泄露](#内存泄露)
  - [性能分析](#性能分析)

## 地址转换

- 内存需要被分成固定大小的页，然后再通过虚拟内存地址到物理内存地址的地址转换，才能到达实际存放数据的物理内存位置。
- 程序看到的内存地址，都是虚拟内存地址，这些虚拟内存还需要通过页表，由系统映射为物理内存。
- 当进程通过 malloc() 申请虚拟内存后，系统并不会立即为其分配物理内存，而是在首次访问时，才通过 `缺页异常` 陷入内核中分配内存。
- 在内存资源紧张时，Linux 通过直接内存回收和定期扫描的方式，来释放文件页和匿名页，以便把内存分配给更需要的进程使用。

## TLB

![TLB](https://github.com/gongluck/images/blob/main/memory/tlb.png)

- 在 CPU 里放了一块缓存芯片，称之为 TLB，全称是地址变换高速缓冲(Translation-Lookaside Buffer)。
- 这块缓存存放了之前已经进行过地址转换的查询结果。当同样的虚拟地址需要进行地址转换的时候，可以直接在 TLB 里面查询结果，而不需要多次访问内存来完成一次转换。

## Buffers/Cache

- Buffer 是磁盘设备的缓存。
- Cache 是文件系统的缓存。
- 读写块设备文件时，会跳过文件系统，直接与磁盘交互，也就是所谓的"裸 I/O"。

## SWAP

- Swap 把磁盘空间当成内存来用，把进程暂时不用的数据存储到磁盘中（换出），当进程访问这些内存时，再从磁盘读取这些数据到内存中（换入）。
- 对匿名页的回收，其实就是通过 Swap 机制，把它们写入磁盘后再释放内存。
- 由于磁盘读写的速度远比内存慢，Swap 会导致严重的内存性能问题。
- Linux 提供了一个 `/proc/sys/vm/swappiness` 选项，用来调整使用 Swap 的积极程度。
- `swapoff -a` 命令关闭 SWAP，`swapon -a` 命令打开 SWAP。
- 在开启 Swap 的服务器中运行，可以用库函数 `mlock()` 或者 `mlockall()` 锁定内存，阻止它们的内存换出。

## NUMA

- NUMA（非一致性内存访问）是一种计算机体系结构设计，用于处理多个处理器（CPU）访问共享内存的问题。
- 在 NUMA 架构中，每个处理器都有自己的本地内存，访问本地内存的速度比访问远程内存要快。因此，NUMA 可以提高多处理器系统的性能。
- 在 NUMA 架构下，每个 Node 都有自己的本地内存空间，而当本地内存不足时，默认既可以从其他 Node 寻找空闲内存，也可以从本地内存回收。
- 可以设置 `/proc/sys/vm/zone_reclaim_mode`，来调整 NUMA 本地内存的回收策略。

## DMA

- DMA 技术，就是直接内存访问(Direct Memory Access)技术，来减少 CPU 等待的时间。
- 本质上，DMA 技术就是在主板上放一块独立的芯片。在进行内存和 I/O 设备的数据传输的时候，不再通过 CPU 来控制数据传输，而直接通过 DMA 控制器(DMA Controller，DMAC)。这块芯片其实就是一个协处理器(Co-Processor)。
- DMAC 最有价值的地方体现在，当要传输的数据特别大、速度特别快，或者传输的数据特别小、速度特别慢的时候。比如，用千兆网卡或者硬盘传输大量数据时，如果都用 CPU 来搬运的话，肯定忙不过来，所以可以选择 DMAC。而当传输很慢的时候，DMAC 可以等数据到齐了，再发送信号，给到 CPU 去处理，而不是让 CPU 在哪里忙等。

## 缓存命中率

- Buffers 和 Cache 可以极大提升系统的 I/O 性能。
- 用缓存命中率，来衡量缓存的使用效率。命中率越高，表示缓存被利用得越充分，应用程序的性能也就越好。
- [cachestat](../tools/command.md#cachestat) 提供了整个操作系统缓存的读写命中情况。
- [cachetop](../tools/command.md#cachetop) 提供了每个进程的缓存命中情况。

## 内存泄露

- [memleak](../tools/command.md#memleak) 可以跟踪系统或指定进程的内存分配、释放请求，然后定期输出一个未释放内存和相应调用栈的汇总情况。

## 性能分析

![内存性能分析](https://github.com/gongluck/images/blob/main/linux/performance/memory.png)

- 禁止 Swap。如果必须开启 Swap，降低 `swappiness` 的值，减少内存回收时 Swap 的使用倾向。
- 减少内存的动态分配。比如，可以使用内存池、大页（HugePage）等。
- 尽量使用缓存和缓冲区来访问数据。比如，可以使用堆栈明确声明内存空间，来存储需要缓存的数据；或者用 Redis 这类的外部缓存组件，优化数据的访问。
- 使用 `cgroups` 等方式限制进程的内存使用情况。这样，可以确保系统内存不会被异常进程耗尽。
- 通过 `/proc/pid/oom_adj` ，调整核心应用的 `oom_score`。这样，可以保证即使内存紧张，核心应用也不会被 OOM 杀死。
