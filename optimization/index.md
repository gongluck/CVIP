# 索引

- [索引](#索引)
  - [索引结构](#索引结构)
  - [内存结构与序列化方案](#内存结构与序列化方案)
  - [降低哈希表的冲突概率](#降低哈希表的冲突概率)
    - [调优哈希函数](#调优哈希函数)
    - [扩容](#扩容)


## 索引结构

- 哈希函数直接把查询关键字转换为数组下标，再通过数组的随机访问特性获取数据。哈希函数的执行时间是常量，数组的随机访问也是常量，时间复杂度就是O(1)。
- 位图是哈希表的变种，限制每个哈希桶只有1个比特位，消耗的空间更少，但仅用于辅助数据的主索引，快速判断对象是否存在。
- 由于哈希表没办法找到关键字相邻的下一个元素，所以哈希表不支持这类操作，可以选择红黑树作为索引，采用二分法查找。
- 如果红黑树过大，内存中放不下时，可以改用B树，将部分索引存放在磁盘上。磁盘访问速度要比内存慢很多，但B树充分考虑了机械磁盘寻址慢、顺序读写快的特点，通过多分支降低了树高，减少了磁盘读写次数。

## 内存结构与序列化方案

- 对于动态(元素是变化的)哈希表，无法避免哈希冲突。
  - 链接法，落到数组同一个位置中的多个数据，通过链表串在一起。使用哈希函数查找到这个位置后，再使用链表遍历的方式查找数据。
  - 开放寻址法，插入时若发现对应的位置已经占用，或者查询时发现该位置上的数据与查询关键字不同，开放寻址法会按既定规则变换哈希函数，计算出下一个数组下标，继续在哈希表中探查正确的位置。
- 链接法序列化数据的代价很大，因为使用了指针后，内存是不连续的。开放寻址法确保所有对象都在数组里，就可以把数组用到的这段连续内存原地映射到文件中。

![数据长度固定](https://github.com/gongluck/images/blob/main/hash/数据长度固定.png)

- 数据的长度是固定的。可以用另一个数组D存放数据，其中D的大小是待存放元素的最大数量，注意，D可以远小于哈希数组的大小。如果哈希表是动态的，支持新建与删除元素操作，还需要把数组D中空闲的位置构建一个单链表，新建时从链表头取元素，删除时将元素归还至链表头部。

![数据长度不固定](https://github.com/gongluck/images/blob/main/hash/数据长度不固定.png)

- 数据的长度并不固定。可以采用有限个定长数组存放数据，用以空间换时间的思想，加快访问速度。D1数组存放长度小于L1的数据，D2数组存放长度在L1和L2之间的数据，以此类推。而哈希表数组H中，每个桶用i位存放该数据在哪个数组中，用j位存放数组下标。查找数据时，前i位寻找数组，后j位作为数组下标直接访问数据。

## 降低哈希表的冲突概率

### 调优哈希函数

- 好的哈希函数，计算量不能大，其次应尽量降低冲突概率。
- 当哈希函数把高信息量的关键字压缩成更小的数组下标时，一定会丢失信息。我们希望只丢失一些无关紧要的信息，尽量多地保留区分度高的信息。

### 扩容

- 装载因子越接近于1，冲突概率就会越大。我们不能改变元素的数量，只能通过扩容提升哈希桶的数量，减少冲突。
- 由于哈希函数必须确保计算出的下标落在数组范围中，而扩容会增加数组的大小，进而影响哈希函数，因此，扩容前存放在哈希表中的所有元素，它们在扩容后的数组中位置都发生了变化。所以，扩容需要新老哈希表同时存在，通过遍历全部数据，用新的哈希函数把关键字放到合适的新哈希桶中。
- 只要把一次性的迁移过程，分为多次后台迁移，且提供服务时能够根据迁移情况选择[新老哈希表](../redis/struct.md#字典)即可。如果单机内存可以存放下新老两张哈希表，那么动态扩容不需要跨主机。反之，扩容过程将涉及新老哈希表所在的两台服务器，实现更为复杂，但原理是相同的。

