# 协程

- [协程](#协程)
  - [高并发](#高并发)
  - [协程](#协程-1)

## 高并发

- 如果想兼顾开发效率，又能保证高并发，协程就是最好的选择。它可以在保持异步化运行机制的同时，用同步方式写代码，这在实现高并发的同时，缩短了开发周期，是高性能服务未来的发展方向。
- 异步编程方式通过非阻塞系统调用和多路复用，把原本属于内核的请求切换能力，放在用户态的代码中执行。不仅减少了每个请求的内存消耗，也降低了切换请求的成本，最终实现了高并发。
- 异步编程违反了代码的内聚性，还需要业务代码关注并发细节，开发成本很高。

## 协程

  ![协程](https://github.com/gongluck/images/blob/main/coroutine/coroutine.png)

- 协程参考内核通过CPU寄存器切换线程的方法，在用户态代码中实现了协程的切换，既降低了切换请求的成本，也使得协程中的业务代码不用关注自己何时被挂起，何时被执行。
- 相比异步编程中要维护一堆数据结构表示中间状态，协程直接用代码表示状态，大大提升了开发效率。

  ![协程切换前](https://github.com/gongluck/images/blob/main/coroutine/协程切换前.png)
  ![协程切换后](https://github.com/gongluck/images/blob/main/coroutine/协程切换后.png)

- 为了保证所有切换都在用户态进行，协程必须重新封装所有的阻塞系统调用，否则，一旦协程触发了线程切换，会导致这个线程进入休眠状态，进而其上的所有协程都得不到执行。
- 协程的高性能，建立在切换必须由用户态代码完成之上，这要求协程生态是完整的，要尽量覆盖常见的组件。
- 为了让协程获得更多的CPU时间，还可以设置所在线程的优先级。
- 为了减少CPU缓存失效的比例，还可以把线程绑定到某个CPU上，增加协程执行时命中CPU缓存的机率。
