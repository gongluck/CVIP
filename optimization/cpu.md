# CPU

- [CPU](#cpu)
  - [CPU多级缓存](#cpu多级缓存)
  - [提升数据缓存的命中率](#提升数据缓存的命中率)
  - [提升指令缓存的命中率](#提升指令缓存的命中率)
  - [提升多核CPU下的缓存命中率](#提升多核cpu下的缓存命中率)
  - [火焰图](#火焰图)

## CPU多级缓存

  ![多级缓存](https://github.com/gongluck/images/blob/main/cpu/多级缓存.png)

- 由于CPU缓存由更快的SRAM构成(内存是由DRAM构成的)，而且离CPU核心更近，如果运算时需要的输入数据是从CPU缓存，而不是内存中读取时，运算速度就会快很多。
- 三级缓存要比一、二级缓存大许多倍，这是因为当下的CPU都是多核心的，每个核心都有自己的一、二级缓存，但三级缓存却是一颗CPU上所有核心共享的。
- 如果CPU所要操作的数据在缓存中，则直接读取，这称为 **缓存命中** 。命中缓存会带来很大的性能提升，代码优化目标是提升CPU缓存的命中率。
- 虽然在冯诺依曼计算机体系结构中，代码指令与数据是放在一起的，但执行时却是分开进入指令缓存与数据缓存的，因此要分开来看二者的缓存命中率。

## 提升数据缓存的命中率

- 对于数据缓存，应在循环体中尽量操作同一块内存上的数据。
- 由于缓存是根据CPU Cache Line批量操作数据的，所以顺序地操作连续内存数据时也有性能提升。

## 提升指令缓存的命中率

- 对于指令缓存，有规律的条件分支能够让CPU的分支预测发挥作用，进一步提升执行效率。
- 当代码中出现if、switch等语句时，意味着此时至少可以选择跳转到两段不同的指令去执行。如果分支预测器可以预测接下来要在哪段代码执行(比如if还是else中的指令)，就可以提前把这些指令放在缓存中，CPU执行时就会很快。
- C/C++语言中编译器还给应用程序员提供了显式预测分支概率的工具，如果if中的条件表达式判断为"真"的概率非常高，可以用likely宏把它括在里面，反之则可以用unlikely宏。当然，CPU自身的条件预测已经非常准了，仅当确信CPU条件预测不会准，且能够知晓实际概率时，才需要加入这两个宏。
 
## 提升多核CPU下的缓存命中率

- 操作系统提供了将进程或者线程绑定到某一颗CPU上运行的能力。
- 当多线程同时执行密集计算，且CPU缓存命中率很高时，如果将每个线程分别绑定在不同的CPU核心上，性能便会获得非常可观的提升。

## 火焰图

- 环境准备
  
  ```shell
  # 安装perf
  # 下载开源工具FlameGraph https://github.com/brendangregg/FlameGraph.git
  ```

- 使用[perf](../tools/shell.md#perf)生成记录

  ```shell
  # 记录
  perf record -g --call-graph dwarf -p pid
  # 转换二进制文件到文本输出
  perf script > out.perf
  ```

- 使用FlameGraph生成火焰图

  ```shell
  # 生成火焰图数据格式
  FlameGraph/stackcollapse-perf.pl out.perf > out.folded
  # 生成火焰图图片
  FlameGraph/flamegraph.pl out.folded > out.svg
  ```
