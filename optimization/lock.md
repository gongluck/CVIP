# 锁

- [锁](#锁)
  - [互斥锁](#互斥锁)
  - [自旋锁](#自旋锁)
  - [读写锁](#读写锁)
  - [乐观锁](#乐观锁)


## 互斥锁

- 互斥锁能够满足各类功能性要求，特别是被锁住的代码执行时间不可控时。
- 互斥锁通过内核执行线程切换及时释放了资源，但性能消耗最大。

## 自旋锁

- 如果能够确定被锁住的代码取到锁后很快就能释放，应该使用自旋锁。
- 自旋锁特别适合基于异步编程实现的高并发服务。

## 读写锁

- 如果能区分出读写操作，读写锁就是第一选择。
- 读写锁允许多个读线程同时持有读锁，提高了并发性。
- 读写锁是有倾向性的，读优先锁很高效，但容易让写线程饿死，而写优先锁会优先服务写线程，但对读线程亲和性差一些。
- 还有一种公平读写锁，它通过把等待锁的线程排队，以略微牺牲性能的方式，保证了某种线程不会饿死，通用性更佳。
- 读写锁既可以使用互斥锁实现，也可以使用自旋锁实现，应根据场景来选择合适的实现。

## 乐观锁

- 当并发访问共享资源，冲突概率非常低的时候，可以选择无锁编程。
- 无锁编程在Web和数据库中有广泛的应用。然而，一旦冲突概率上升，就不适合使用它，因为它解决冲突的重试成本非常高。
