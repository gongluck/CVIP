# C++基础

- [C++基础](#c基础)
  - [i++与++i](#i与i)
  - [不用中间变量，交换a和b的值](#不用中间变量交换a和b的值)
  - [main函数执行完之后还会执行其他语句吗？](#main函数执行完之后还会执行其他语句吗)
  - [宏参数的连接](#宏参数的连接)
  - [const和#define的特点和区别](#const和define的特点和区别)
  - [const的作用](#const的作用)
  - [宏函数和内联函数](#宏函数和内联函数)
  - [static的作用](#static的作用)
  - [字节对齐](#字节对齐)
  - [C++中4种指针转化运算符](#c中4种指针转化运算符)

## i++与++i

- 内建数据类型的情况，效率没有区别。
- 自定义数据类型的情况，++i效率更高。++i可以返回对象的引用，i++必须返回对象的值。

## 不用中间变量，交换a和b的值

```C++
void swap(int& a, int& b)
{
    //1 可能产生数据溢出
    a = a + b;
    b = a - b;
    a = a - b;
    //2
    a ^= b;
    b ^= a;
    a ^= b;
}
```

## main函数执行完之后还会执行其他语句吗？

可以用atexit()函数注册程序正常终止时要被调用的函数，在main函数结束时，按注册时的顺序反序调用这些函数。

```C++
#include <stdlib.h>
int atexit(void (*)void);
```

## 宏参数的连接

```C++
// #把宏参数变成一个字符串
#define FUNC(a) #a
const char* str = FUNC1(把宏参数变成一个字符串);//const char* str = "把宏参数变成一个字符串";

// ##把两个宏参数粘合在一起
#define FUNC(a, b) a##b
const char* str = FUNC2("把两个宏参数", "粘合在一起");//const char* str = "把两个宏参数""粘合在一起";
```

## const和#define的特点和区别

- #define常量没有数据类型，生命周期止于编译期，它存在于程序的代码段。
- const常量有数据类型，存在于程序的数据段，并在堆栈中分配了空间。

## const的作用

- 定义常量，编译器可以对其进行数据静态类型安全检查。
- 修饰函数引用类型形参，节省临时对象的构造、复制和析构过程的消耗，避免引用对象被修改。
- 修饰函数返回值，避免返回值被直接修改。
- 修饰类成员函数，避免修改数据成员。

## 宏函数和内联函数

- 宏函数使用预处理器实现，没有参数压栈、代码生成等操作，效率高。但是只是简单的文本替换，没有参数有效性检测和类型检查，返回值也不能被强制转换为合适的类型。
- 内联函数在编译时展开，可以直接镶嵌到目标代码中。内联函数是函数，可以完成类型检查功能。

## static的作用

- 函数体中的静态变量，在函数被调用的过程中维持值不变。
- 模块内的全局静态变量，可以被模块内所有函数访问，但不能被其他模块访问。
- 模块内的静态函数，只能被模块内的其他函数调用。

## 字节对齐

- 结构体变量的首地址能被其**最宽基本类型成员的大小和编译器默认对齐较小值**所整除。
- 结构体每个成员相对于结构体首地址的偏移量都是**成员大小和编译器默认对齐较小值**的整数倍。
- 结构体总大小为**结构体最宽基本类型成员大小和编译器默认对齐较小值**的整数倍。

## C++中4种指针转化运算符

- const_cast:特定情况下，将const限制解除。
- dynamic_cast:可以在运行时将一个指向派生类的基类指针还原成原来的派生类指针。
- reinterpret_cast:指针间强行转化。
- static_cast:安全类型转化，转换定义了相关构造函数、类型转换函数或者有继承关系的类，或者将数域宽度大的类型转换到较小的类型。

