# C++基础

- [C++基础](#c基础)
  - [i++与++i](#i与i)
  - [不用中间变量，交换a和b的值](#不用中间变量交换a和b的值)
  - [main函数执行完之后还会执行其他语句吗？](#main函数执行完之后还会执行其他语句吗)
  - [宏参数的连接](#宏参数的连接)
  - [const和#define的特点和区别](#const和define的特点和区别)
  - [const的作用](#const的作用)
  - [宏函数和内联函数](#宏函数和内联函数)
  - [static的作用](#static的作用)
  - [字节对齐](#字节对齐)
  - [C++中4种指针转化运算符](#c中4种指针转化运算符)
  - [虚析构函数](#虚析构函数)
  - [虚函数的实现](#虚函数的实现)
  - [构造函数中调用虚函数](#构造函数中调用虚函数)

## i++与++i

- 内建数据类型的情况，效率没有区别。
- 自定义数据类型的情况，++i效率更高。++i可以返回对象的引用，i++必须返回对象的值。

## 不用中间变量，交换a和b的值

```C++
void swap(int& a, int& b)
{
    //1 可能产生数据溢出
    a = a + b;
    b = a - b;
    a = a - b;
    //2
    a ^= b;
    b ^= a;
    a ^= b;
}
```

## main函数执行完之后还会执行其他语句吗？

可以用atexit()函数注册程序正常终止时要被调用的函数，在main函数结束时，按注册时的顺序反序调用这些函数。

```C++
#include <stdlib.h>
int atexit(void (*)void);
```

## 宏参数的连接

```C++
// #把宏参数变成一个字符串
#define FUNC(a) #a
const char* str = FUNC1(把宏参数变成一个字符串);//const char* str = "把宏参数变成一个字符串";

// ##把两个宏参数粘合在一起
#define FUNC(a, b) a##b
const char* str = FUNC2("把两个宏参数", "粘合在一起");//const char* str = "把两个宏参数""粘合在一起";
```

## const和#define的特点和区别

- #define常量没有数据类型，生命周期止于编译期，它存在于程序的代码段。
- const常量有数据类型，存在于程序的数据段，并在堆栈中分配了空间。

## const的作用

- 定义常量，编译器可以对其进行数据静态类型安全检查。
- 修饰函数引用类型形参，节省临时对象的构造、复制和析构过程的消耗，避免引用对象被修改。
- 修饰函数返回值，避免返回值被直接修改。
- 修饰类成员函数，避免修改数据成员。

## 宏函数和内联函数

- 宏函数使用预处理器实现，没有参数压栈、代码生成等操作，效率高。但是只是简单的文本替换，没有参数有效性检测和类型检查，返回值也不能被强制转换为合适的类型。
- 内联函数在编译时展开，可以直接镶嵌到目标代码中。内联函数是函数，可以完成类型检查功能。

## static的作用

- 函数体中的静态变量，在函数被调用的过程中维持值不变。
- 模块内的全局静态变量，可以被模块内所有函数访问，但不能被其他模块访问。
- 模块内的静态函数，只能被模块内的其他函数调用。

## 字节对齐

- 结构体变量的首地址能被其**最宽基本类型成员的大小和编译器默认对齐较小值**所整除。
- 结构体每个成员相对于结构体首地址的偏移量都是**成员大小和编译器默认对齐较小值**的整数倍。
- 结构体总大小为**结构体最宽基本类型成员大小和编译器默认对齐较小值**的整数倍。

## C++中4种指针转化运算符

- const_cast:特定情况下，将const限制解除。
- dynamic_cast:可以在运行时将一个指向派生类的基类指针还原成原来的派生类指针。
- reinterpret_cast:指针间强行转化。
- static_cast:安全类型转化，转换定义了相关构造函数、类型转换函数或者有继承关系的类，或者将数域宽度大的类型转换到较小的类型。

## 虚析构函数

- 只有当一个类被用来作为基类时，才会把析构函数写成虚析构函数，以按正确完整的顺序调用基类和派生类的析构函数。

## 虚函数的实现

```C++
#include <iostream>

class A
{
public:virtual void AA() {}
};
class B
{
public:virtual void BB() {}
};
class C : public A
{
public:virtual void CC() {}
};
class D : public A, public B
{
	virtual void DD() {}
};
class E : public D
{
	virtual void EE() {}
};
class F : public A, public E
{
	virtual void FF() {}
};
int main()
{
	A a; B b; C c; D d; E e; F f;
	return 0;
}
```

![C++虚函数表](https://github.com/gongluck/images/blob/main/C++虚函数表.png)

- 如果类中有虚函数，编译器会至少为这个类分配一个成员指针指向一张虚函数表，表中每一项指向一个虚函数地址。
- 多重继承情况下，为每个含有虚函数的基类分配一个虚表指针。
- 每个派生类的虚函数表继承它各个基类的虚函数表。
- 如果派生类覆盖了基类对应的一个虚函数，则派生类的虚函数表的该项指向重载后的虚函数。
- 在类对象的内存布局中，首先是该类的虚函数表指针，然后才是对象数据。
- 在通过对象指针调用一个虚函数时，编译器生成的代码将先获取对象类的虚函数表指针，然后调用虚函数表中对应的一项。
- 如果派生类自身新增虚函数的话，那么这个函数地址会被添加到复制基类的虚函表最后一个位置中，如果是多继承的情况下，会被添加到继承顺序最先继承的基类虚函数表中。

## 构造函数中调用虚函数

- 基类的构造函数在派生类构造函数之前执行，当基类构造函数运行时，派生类数据成员还没有被初始化。