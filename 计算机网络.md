# 计算机网络

- [计算机网络](#计算机网络)
  - [TCP](#tcp)
    - [主机到主机（Host-To-Host）](#主机到主机host-to-host)
    - [连接（Connection）](#连接connection)
    - [双工](#双工)
    - [可靠性](#可靠性)
    - [TCP 的握手和挥手](#tcp-的握手和挥手)
      - [TCP 协议的基本操作](#tcp-协议的基本操作)
      - [建立连接的过程（3次握手）](#建立连接的过程3次握手)
      - [断开连接的过程（4次挥手）](#断开连接的过程4次挥手)
      - [TCP 为什么是3次握手，4次挥手？](#tcp-为什么是3次握手4次挥手)
    - [TCP 的拆包和粘包](#tcp-的拆包和粘包)
      - [TCP Segment](#tcp-segment)
      - [Sequence Number 和 Acknowledgement Number](#sequence-number-和-acknowledgement-number)
      - [MSS（Maximun Segment Size）](#mssmaximun-segment-size)
      - [TCP 协议是如何恢复数据的顺序的，TCP 拆包和粘包的作用是什么？](#tcp-协议是如何恢复数据的顺序的tcp-拆包和粘包的作用是什么)
    - [滑动窗口和流速控制](#滑动窗口和流速控制)
      - [请求/响应模型](#请求响应模型)
      - [滑动窗口（Sliding Window）](#滑动窗口sliding-window)
      - [重传](#重传)
      - [快速重传](#快速重传)
      - [流速控制](#流速控制)
      - [滑动窗口和流速控制是怎么回事？](#滑动窗口和流速控制是怎么回事)
  - [UDP](#udp)
    - [UDP 的封包格式](#udp-的封包格式)
  - [UDP 与 TCP的区别](#udp-与-tcp的区别)
    - [目的差异](#目的差异)
    - [可靠性差异](#可靠性差异)
    - [连接 vs 无连接](#连接-vs-无连接)
    - [流控技术（Flow Control）](#流控技术flow-control)
    - [传输速度](#传输速度)
    - [场景差异](#场景差异)
  - [IP 协议](#ip-协议)
    - [IP 协议的工作原理](#ip-协议的工作原理)
      - [分片（Fragmentation）](#分片fragmentation)
      - [增加协议头（IP Header）](#增加协议头ip-header)
    - [IPv4 寻址](#ipv4-寻址)
    - [路由（Routing）](#路由routing)
    - [IPv6](#ipv6)
      - [IPv6 的寻址](#ipv6-的寻址)
    - [NAT 网络地址转换技术](#nat-网络地址转换技术)
    - [ARP 地址解析协议](#arp-地址解析协议)
  - [网络编程](#网络编程)
    - [Socket](#socket)
      - [服务端 Socket 的绑定](#服务端-socket-的绑定)
    - [I/O 多路复用技术](#io-多路复用技术)
    - [响应式（Reactive）](#响应式reactive)
    - [epoll 为什么用红黑树？](#epoll-为什么用红黑树)
    - [I/O 的编程模型](#io-的编程模型)
  - [Web技术](#web技术)
    - [统一资源定位符（URL）](#统一资源定位符url)
    - [DNS（Domain Name System，域名系统）](#dnsdomain-name-system域名系统)
      - [根域名服务器](#根域名服务器)
      - [域名分级和数据分区](#域名分级和数据分区)
      - [DNS 查询过程](#dns-查询过程)
    - [内容分发网络（Content Dilivery Network，CDN）](#内容分发网络content-dilivery-networkcdn)
    - [HTTP 超文本传输协议](#http-超文本传输协议)
      - [请求响应和长连接](#请求响应和长连接)
      - [HTTP 2.0 的多路复用](#http-20-的多路复用)
      - [HTTP 方法和 RestFul 架构](#http-方法和-restful-架构)
    - [网络爬虫](#网络爬虫)

## TCP

    TCP（Transport Control Protocol）是一个传输层协议，提供 Host-To-Host 数据的可靠传输，支持全双工，是一个连接导向的协议。

### 主机到主机（Host-To-Host）

    TCP 提供的是 Host-To-Host 传输，一台主机通过 TCP 发送数据给另一台主机。
    TCP 协议往上是应用到应用（Application-To-Application）的协议。端口号用于区分应用。
    TCP 不负责实际地址到地址（Address-To-Address）的传输，因此 TCP 协议把 IP 地址给底层的互联网层处理。

### 连接（Connection）

    连接是通信双方的一个约定，目标是让两个在通信的程序之间产生一个默契，保证两个程序都在线，而且尽快地响应对方的请求，这就是连接（Connection）。
    连接是传输层的概念。
    会话是应用的行为。连接会断开，聊天窗口没关，会话还在。

### 双工

    任何时刻数据都可以双向收发，这就是全双工，全双工需要大于 1 条线路。
    这里的线路，是一个抽象概念，可以并发地处理信号，达到模拟双工的目的。

### 可靠性

    可靠性指数据保证无损传输。如果发送方按照顺序发送，然后数据无序地在网络间传递，就必须有一种算法在接收方将数据恢复原有的顺序。

### TCP 的握手和挥手

    TCP 是一个连接导向的协议，设计有建立连接（握手）和断开连接（挥手）的过程。

#### TCP 协议的基本操作

  - 如果一个 Host 主动向另一个 Host 发起连接，称为 SYN（Synchronization），请求同步；
  - 如果一个 Host 主动断开请求，称为 FIN（Finish），请求完成；
  - 如果一个 Host 给另一个 Host 发送数据，称为 PSH（Push），数据推送。

    以上 3 种情况，接收方收到数据后，都需要给发送方一个 ACK（Acknowledgement）响应。请求/响应的模型是可靠性的要求，如果一个请求没有响应，发送方可能会认为自己需要重发这个请求。

#### 建立连接的过程（3次握手）

    因为要保持连接和可靠性约束，TCP 协议要保证每一条发出的数据必须给返回，返回数据叫作 ACK（也就是响应）。

  - 客户端发消息给服务端（SYN）**（1）**
  - 服务端准备好进行连接
  - 服务端针对客户端的 SYN 给一个 ACK **（2）**
  - 因为服务端还没有确定客户端是否准备好了。服务端马上给客户端发送数据，这个时候客户端可能还没有准备好接收数据。因此还需要增加下面过程
  - 服务端发送一个 SYN 给客户端 **（2）**
  - 客户端准备就绪
  - 客户端给服务端发送一个 ACK **（3）**

#### 断开连接的过程（4次挥手）

  - 客户端要求断开连接，发送一个断开的请求，这个叫作（FIN） **（1）**
  - 服务端收到请求，然后给客户端一个 ACK，作为 FIN 的响应 **（2）**
  - 这个时候服务端不能马上传 FIN，因为断开连接要处理的问题比较多，比如说服务端可能还有发送出去的消息没有得到 ACK；也有可能服务端自己有资源要释放。因此断开连接不能像握手那样操作——将两条消息合并
  - 服务端经过一个等待，确定可以关闭连接了，再发一条 FIN 给客户端 **（3）**
  - 客户端收到服务端的 FIN，同时客户端也可能有自己的事情需要处理完，比如客户端有发送给服务端没有收到 ACK 的请求，客户端自己处理完成后，再给服务端发送一个 ACK **（4）**

#### TCP 为什么是3次握手，4次挥手？

    TCP 是一个双工协议，为了让双方都保证，建立连接的时候，连接双方都需要向对方发送 SYC（同步请求）和 ACK（响应）。
    握手阶段双方都没有烦琐的工作，因此一方向另一方发起同步（SYN）之后，另一方可以将自己的 ACK 和 SYN 打包作为一条消息回复，因此是 3 次握手——需要 3 次数据传输。
    到了挥手阶段，双方都可能有未完成的工作。收到挥手请求的一方，必须马上响应（ACK），表示接收到了挥手请求。
    启用延迟确认的情况下是三次挥手。

### TCP 的拆包和粘包

    TCP 是一个传输层协议。TCP 发送数据的时候，往往不会将数据一次性发送，而是将数据拆分成很多个部分，然后再逐个发送。
    为了稳定性，一次发送的数据越多，出错的概率越大。
    为了效率，网络中有时候存在着并行的路径，拆分数据包就能更好地利用这些并行的路径。
    发送和接收数据的时候，都存在着缓冲区。大量的应用频繁地通过网卡收发数据，这个时候，网卡只能一个一个处理应用的请求。当网卡忙不过来的时候，数据就需要排队，也就是将数据放入缓冲区。

#### TCP Segment

  ![TCP段](https://github.com/gongluck/images/blob/main/TCP段.png)

 - **Source Port/Destination Port** 描述的是发送端口号和目标端口号，代表发送数据的应用程序和接收数据的应用程序。
 - **Sequence Number 和 Achnowledgment Number** 是保证可靠性的两个关键。
 - Data Offset 是一个偏移量。这个量存在的原因是 TCP Header 部分的长度是可变的，因此需要一个数值来描述数据从哪个字节开始。
 - URG/ACK/PSH/RST/SYN/FIN 是几个标志位，用于描述 TCP 段的行为。
   - URG 代表这是一个紧急数据，比如远程操作的时候，用户按下了 Ctrl+C，要求终止程序，这种请求需要紧急处理。
   - **ACK 代表响应**，所有的消息都必须有 ACK，这是 TCP 协议确保稳定性的一环。
   - **PSH 代表数据推送**，也就是在传输数据的意思。
   - **SYN 同步请求**，也就是申请握手。
   - **FIN 终止请求**，也就是挥手。
 - **Window 也是 TCP 保证稳定性并进行流量控制的工具**。
 - Checksum 是校验和，用于校验 TCP 段有没有损坏。
 - Urgent Pointer 指向最后一个紧急数据的序号（Sequence Number）。有时候紧急数据是连续的很多个段，所以需要提前告诉接收方进行准备。
 - Options 中存储了一些可选字段，比如 MSS（Maximun Segment Size）。
 - Padding 存在的意义是因为 Options 的长度不固定，需要 Pading 进行对齐。 

#### Sequence Number 和 Acknowledgement Number

    发送数据的时候，为每一个 TCP 段分配一个自增的 Sequence Number。接收数据的时候，虽然得到的是乱序的 TCP 段，但是可以通过 Seq 进行排序。
    每个 TCP 段发送时，发送方已经接收了多少数据，用 Acknowledgement Number 表示。
    无论 Seq 还是 ACK，都是针对“对方”而言的。是对方发送的数据和对方接收到的数据。

#### MSS（Maximun Segment Size）

    MSS 是 TCP Header 中的可选项（Options），这个可选项控制了 TCP 段的大小，它是一个协商字段（Negotiate）。协议是双方都要遵循的标准，因此配置往往不能由单方决定，需要双方协商。
    TCP 段的大小（MSS）涉及发送、接收缓冲区的大小设置，双方实际发送接收封包的大小，对拆包和粘包的过程有指导作用，因此需要双方去协商。
    如果这个字段设置得非常大，对方可能会拒绝，作为服务的提供方，可能不会愿意接收太大的 TCP 段。因为大的 TCP 段，会降低性能，比如内存使用的性能。还有就是资源的占用。一个用户占用服务器太多的资源，意味着其他的用户就需要等待或者降低他们的服务质量。支持 TCP 协议工作的 IP 协议，工作效率会下降。TCP 协议不肯拆包，IP 协议就需要拆出大量的包。因为在网络中，每次能够传输的数据不可能太大，这受限于具体的网络传输设备，也就是物理特性。但是 IP 协议，拆分太多的封包并没有意义。因为可能会导致属于同个 TCP 段的封包被不同的网络路线传输，这会加大延迟。同时，拆包，还需要消耗硬件和计算资源。
    MSS 太小的情况下，会浪费传输资源（降低吞吐量）。因为数据被拆分之后，每一份数据都要增加一个头部。如果 MSS 太小，那头部的数据占比会上升，这让吞吐量成为一个灾难。

#### TCP 协议是如何恢复数据的顺序的，TCP 拆包和粘包的作用是什么？

    TCP 拆包的作用是将任务拆分处理，降低整体任务出错的概率，以及减小底层网络处理的压力。拆包过程需要保证数据经过网络的传输，又能恢复到原始的顺序。TCP 利用（发送字节数、接收字节数）的唯一性来确定封包之间的顺序关系。
    粘包是为了防止数据量过小，导致大量的传输，而将多个 TCP 段合并成一个发送。

### 滑动窗口和流速控制

#### 请求/响应模型

    TCP 中每个发送的请求都需要响应。如果一个请求没有收到响应，发送方就会认为这次发送出现了故障，会触发重发。
    让发送方有请求就发送出去，而不是等待响应。通过这样的处理方式，发送的数据连在了一起，响应的数据也连在了一起，吞吐量就提升了。

#### 滑动窗口（Sliding Window）

  ![滑动窗口](https://github.com/gongluck/images/blob/main/滑动窗口.png)

#### 重传

    如果发送过程中，部分数据没能收到 ACK 就可能发生重传。
    如果后来段重传成功（接收到 ACK），那么窗口就会继续右移。如果段发送失败，还是没能收到 ACK，那么接收方也会抛弃后面已接收段。这样从失败段开始之后的数据都需要重发。

#### 快速重传

    在 TCP 协议中，如果接收方想丢弃某个段，可以选择不发 ACK。发送端超时后，会重发这个 TCP 段。而有时候，接收方希望催促发送方尽快补发某个 TCP 段，这个时候可以使用快速重传能力。
    例如段 1、段 2、段 4 到了，但是段 3 没有到。 接收方可以发送多次段 3 的 ACK。如果发送方收到多个段 3 的 ACK，就会重发段 3。这个机制称为快速重传。这和超时重发不同，是一种催促的机制。
    为了不让发送方误以为段 3 已经收到了，在快速重传的情况下，接收方即便收到发来的段 4，依然会发段 3 的 ACK（不发段 4 的 ACK），直到发送方把段 3 重传。
    实际操作中，每个 TCP 段的大小不同，限制数量会让接收方的缓冲区不好操作，因此实际操作中窗口大小单位是字节数。

#### 流速控制

    发送、接收窗口的大小可以用来控制 TCP 协议的流速。窗口越大，同时可以发送、接收的数据就越多，支持的吞吐量也就越大。当然，窗口越大，如果数据发生错误，损失也就越大，因为需要重传越多的数据。

#### 滑动窗口和流速控制是怎么回事？

    滑动窗口是 TCP 协议控制可靠性的核心。发送方将数据拆包，变成多个分组。然后将数据放入一个拥有滑动窗口的数组，依次发出，仍然遵循先入先出（FIFO）的顺序，但是窗口中的分组会一次性发送。窗口中序号最小的分组如果收到 ACK，窗口就会发生滑动；如果最小序号的分组长时间没有收到 ACK，就会触发整个窗口的数据重新发送。
    另一方面，在多次传输中，网络的平均延迟往往是相对固定的，这样 TCP 协议可以通过双方协商窗口大小控制流速。

## UDP

    UDP（User Datagram Protocol），目标是在传输层提供直接发送报文（Datagram）的能力。Datagram 是数据传输的最小单位。UDP 协议不会帮助拆分数据，它的目标只有一个，就是发送报文。
    因为传输层协议在承接上方应用层的调用，需要提供应用到应用的通信——因此要附上端口号。每个端口，代表不同的应用。传输层下层的 IP 协议，承接传输层的调用，将数据从主机传输到主机。IP 层不能区分应用，导致哪怕是在 IP 协议上进行简单封装，也需要单独一个协议。这就构成了 UDP 协议的市场空间。

### UDP 的封包格式

  ![UDP报文](https://github.com/gongluck/images/blob/main/UDP报文.png)

  - **Source Port** 是源端口号。因为 UDP 协议的特性（不需要 ACK），因此这个字段是可以省略的。但有时候对于防火墙、代理来说，Source Port 有很重要的意义，它们需要用这个字段行过滤和路由。
  - **Destination Port** 是目标端口号（这个字段不可以省略）。
  - Length 是消息体长度。
  - Checksum 是校验和，作用是检查封包是否出错。
  - Data octets 就是一个字节一个字节的数据，Octet 是 8 位。

## UDP 与 TCP的区别

### 目的差异

    TCP 协议的核心目标是提供可靠的网络传输，而 UDP 的目标是在提供报文交换能力基础上尽可能地简化协议轻装上阵。

### 可靠性差异

    TCP 核心是要在保证可靠性提供更好的服务。TCP 会有握手的过程，需要建立连接，保证双方同时在线。而且TCP 有时间窗口持续收集无序的数据，直到这一批数据都可以合理地排序组成连续的结果。
    UDP 并不具备以上这些特性，它只管发送数据封包，而且 UDP 不需要 ACK，这意味着消息发送出去成功与否 UDP 是不管的。

### 连接 vs 无连接

    TCP 是一个面向连接的协议（Connection-oriented Protocol），传输数据必须先建立连接。 
    UDP 是一个无连接协议（Connection-less Protocol），数据随时都可以发送，只提供发送封包（Datagram）的能力。

### 流控技术（Flow Control）

    TCP 使用了流控技术来确保发送方不会因为一次发送过多的数据包而使接收方不堪重负。TCP 在发送缓冲区中存储数据，并在接收缓冲区中接收数据。当应用程序准备就绪时，它将从接收缓冲区读取数据。如果接收缓冲区已满，接收方将无法处理更多数据，并将其丢弃。UDP 没有提供类似的能力。

### 传输速度

    UDP 协议简化，封包小，没有连接、可靠性检查等，因此单纯从传输速度上讲，UDP 更快。

### 场景差异

    TCP 每个数据封包都需要确认，因此天然不适应高速数据传输场景，比如观看视频（流媒体应用）、网络游戏（TCP 有延迟）等。具体来说，如果网络游戏用 TCP，每个封包都需要确认，可能会造成一定的延迟；再比如音、视频传输天生就允许一定的丢包率；Ping 和 DNSLookup，这类型的操作只需要一次简单的请求/返回，不需要建立连接，用 UDP 就足够了。
    近些年有一个趋势，TCP/UDP 的边界逐渐变得模糊，UDP 应用越来越多。比如传输文件，如果考虑希望文件无损到达，可以用 TCP。如果考虑希望传输足够块，就可能会用 UDP。再比如 HTTP 协议，如果考虑请求/返回的可靠性，用 TCP 比较合适。但是像 HTTP 3.0 这类应用层协议，从功能性上思考，暂时没有找到太多的优化点，但是想要把网络优化到极致，就会用 UDP 作为底层技术，然后在 UDP 基础上解决可靠性。
    所以理论上，任何一个用 TCP 协议构造的成熟应用层协议，都可以用 UDP 重构。这就好比，本来用一个工具可以解决所有问题，但是如果某一类问题体量非常大，就会专门为这类问题创造工具。因此，UDP 非常适合需要定制工具的场景。
    UDP 不提供可靠性，不代表我们不能解决可靠性。UDP 的核心价值是灵活、轻量，构造了最小版本的传输层协议。在这个之上，还可以实现连接（Connection），实现会话（Session），实现可靠性（Reliability）……

## IP 协议

    IP 协议（Internet Protocol）是一个处于垄断地位的网络层协议。为传输层提供 Host-To-Host 的能力，需要底层数据链路层的支持。
    IP 协议并不负责数据的可靠性。传输数据时，数据被切分成一个个数据封包。IP 协议上层的传输层协议会对数据进行一次拆分，IP 协议还会进一步进行拆分。进行两次拆分是为了适配底层的设备。

### IP 协议的工作原理

    IP 协议接收 IP 协议上方的 Host-To-Host 协议传来的数据，然后进行拆分，这个能力叫作分片（Fragmentation）。然后 IP 协议为每个片段（Fragment）增加一个 IP 头（Header），组成一个IP 封包（Datagram）。之后，IP 协议调用底层的局域网（数据链路层）传送数据。最后 IP 协议通过寻址和路由能力最终把封包送达目的地。

#### 分片（Fragmentation）

    分片就是把数据切分成片。 
    IP 协议通过它下层的局域网（链路层）协议传输数据，因此需要适配底层传输网络的传输能力。数据太大通常就不适合底层网络传输，这就需要把大的数据切片。
    当然也可能选择不切片，IP 协议提供了一个能力就是把封包标记为不切片，当底层网络看到不切片的封包，又没有能力传输的时候，就会丢弃这个封包。
    在网络环境中往往存在多条路径，一条路径断了，说不定其他路径可以连通。

#### 增加协议头（IP Header）

    切片完成之后，IP 协议会为每个切片（数据封包 Datagram）增加一个协议头。

  ![IP段](https://github.com/gongluck/images/blob/main/IP段.png)

  - IPv4 的地址是 4 组 8 位的数字，总共是 32 位。
  - **Type Of Service 服务的类型**，是为了响应不同的用户诉求，用来选择延迟、吞吐量和丢包率之间的关系。
  - IHL（Internet Header Length）用来描述 IP 协议头的大小。所以 IP 协议头的大小是可变的。IHL 只有 4 位，最大值 1111 = 15。最大是 15 个双字（15*4 字节 = 60 字节）。
  - Total Length 定义报文（封包 Datagram）的长度。
  - Identification（报文的 ID），发送方分配，代表顺序。
  - **Fragment offset 描述要不要分包（拆分），以及如何拆分。**
  - **Time To Live 描述封包存活的时间**。因此每个 IP 封包发送出去后，就开始销毁倒计时。如果倒计时为 0，就会销毁。比如中间的路由器看到一个 TTL 为 0 的封包，就直接丢弃。
  - **Protocol 是描述上层的协议**，比如 TCP = 6，UDP = 17。
  - Options 代表可选项。
  - Checksum 用来检验封包的正确性，如果 Checksum 对不上，就需要选择丢弃这个封包。

### IPv4 寻址

    IPv4 地址是 4 个 8 位（Octet）排列而成，总共可以编址 43 亿个地址。
    IP 协议的寻址过程需要逐级找到网络，最后定位设备。
    
    步骤 1：找到顶层网络
    比如103.16.3.1最顶层的网络号可以和255.0.0.0（子网掩码）做位与运算得到
    103.16.3.1 & 255.0.0.0 = 103.0.0.0
    因此103.0.0.0就是103.16.3.1所在的顶层网络。
    
    步骤 2：找到下一层网络
    接下来要找到下一级网络，就需要用 IP 地址和下一级的子网掩码做位与运算。 
    103.16.3.1 & 255.255.0.0 = 103.16.0.0
    其中103.16.0.0就是下一级的网络号。
    
    步骤 3：找到再下一级网络
    接下来使用255.255.255.0子网掩码找到下一级网络是103.16.3.0。
    
    步骤 4：定位设备
    设备就在子网103.16.3.0中，最终找到的设备号是1。
    
    当然子网掩码也不一定都是255，比如这个子网掩码255.240.0.0也是可以的。但通常把 IPv4 的网络分成这样 4 层。

### 路由（Routing）

    在寻址过程中，数据总是存于某个局域网中。如果目的地在局域网中，就可以直接定位到设备了。如果目的地不在局域网中，这个时候，就需再去往其他网络。
    由于网络和网络间是网关在连接，因此如果目的地 IP 不在局域网中，就需要为 IP 封包选择通往下一个网络的路径，其实就是选择其中一个网关。
    路由（Routing）本质是路径的选择。

### IPv6

    IPv4 的地址是 4 个 8 位（octet），总共 32 位。 
    IPv6 的地址是 8 个 16 位（hextet），总共 128 位。
    IPv6 解决的是地址耗尽的问题。因为解决了地址耗尽的问题，所以很多其他问题也得到了解决，比如说减少了子网，更小的封包头部体积，最终提升了性能等。

#### IPv6 的寻址

    IPv6 地址很充裕，因此对网络的划分和 IPv4 有很显著的差异。
    IPv6 的寻址分成了几种类型：
        全局单播寻址（和 IPv4 地址作用差不多，在互联网中通过地址查找一个设备，简单来说，单播就是 1 对 1）；
        本地单播（类似 IPv4 里的一个内部网络，要求地址必须以fe80开头，类似我们 IPv4 中127开头的地址）；
        分组多播（Group Multicast），类似今天我们说的广播，将消息发送给多个接收者；
        任意播（Anycast），这个方式比较特殊。

  - 全局单播
    - **IPv6 地址太多，因此不再需要子网掩码，而是直接将 IPv6 的地址分区即可。**
    - 在实现全局单播时，IPv6 地址通常分成 3 个部分：
      - 站点前缀（Site Prefix）48bit，一般是由 ISP（Internet Service Providor，运营商）或者RIR（Regional Internet Registry， 地区性互联网注册机构），RIR 将 IP 地址分配给运营商；
      - 子网号（Subnet ID），16bit，用于站点内部区分子网；
      - 接口号（Interface ID）， 64bit，用于站点内部区分设备。
  - 本地单播
    - 理论上，虽然 IPv6 可以将所有的设备都连入一个网络。但在实际场景中，很多公司还是需要一个内部网络的。这种情况在 IPv6 的设计中属于局域网络。
    - 本地单播地址必须以fe80开头，后面 64 位的 0，然后接上 54 位的设备编号。
  - 分组多播
    - 有时候，需要实现广播。所谓广播，就是将消息同时发送给多个接收者。
    - IPv6 中设计了分组多播，来实现广播的能力。当 IP 地址以 8 个 1 开头，也就是ff00开头，后面会跟上一个分组的编号时，就是在进行分组多播。
    - 这个时候，需要一个广播设备，在这个设备中已经定义了这些分组编号，并且拥有分组下所有设备的清单，这个广播设备会帮助我们将消息发送给对应分组下的所有设备。
  - 任意播（Anycast）
    - 任意播，本质是将消息发送给多个接收方，并选择一条最优的路径。
    - 比如说在一个网络中有多个授时服务，这些授时服务都共享了一个任播地址。当一个客户端想要获取时间，就可以将请求发送到这个任播地址。客户端的请求扩散出去后，可能会找到授时服务中的一个或者多个，但是距离最近的往往会先被发现。这个时候，客户端就使用它第一次收到的授时信息修正自己的时间。

### NAT 网络地址转换技术

    在一个局域网中，我们不可以将消息从一个接口（网卡）发送到另一个接口（网卡），而是要通过交换机。
    数据的发送方，将自己的 MAC 地址、目的地 MAC 地址，以及数据作为一个链路层分组（Packet），也称作 Frame 或者封包，发送给交换机。交换机再根据目的地 MAC 地址，将数据转发到目的地的网络接口（网卡）。
    如果 IP 协议要传输数据，就要将数据转换成为链路层的分组，然后才可以在链路层传输。
    MTU 指的是 Maximun Transmission Unit，最大传输单元，意思是链路层网络允许的最大传输数据分组的大小。因此 IP 协议要根据 MTU 拆分封包。
    NAT 技术转换的是 IP 地址，私有 IP 通过 NAT 转换为公网 IP 发送到服务器。服务器的响应，通过 NAT 转换为私有 IP，返回给客户端。通过这种方式，就解决了内网和外网的通信问题。
    NAT 需要作为一个中间层替换 IP 地址。 发送的时候，NAT 替换源 IP 地址（也就是将内网 IP 替换为出口 IP）；接收的时候，NAT 替换目标 IP 地址（也就是将出口 IP 替换回内网 IP 地址）。
    NAT 需要缓存内网 IP 地址和出口 IP 地址 + 端口的对应关系。也就是说，发送的时候，NAT 要为每个替换的内网 IP 地址分配不同的端口，确保出口 IP 地址+ 端口的唯一性，这样当服务器返回数据的时候，就可以根据出口 IP 地址 + 端口找到内网 IP。

### ARP 地址解析协议

    一个中间服务帮助根据 IP 地址找到 MAC 地址——这就是地址解析协议（Address Resolution Protocol，ARP）。
    如果一个网络接口已经知道目标 IP 地址对应的 MAC 地址了，它会将数据直接发送给交换机，交换机将数据转发给目的地。
    如果网络接口不知道目的地地址，地址解析协议就开始工作了。发送接口会发送一个广播查询给到交换机，交换机将查询转发给所有接口。
    如果某个接口发现自己就是对方要查询的接口，则会将自己的 MAC 地址回传。接下来，会在交换机和发送接口的 ARP 表中，增加一个缓存条目。
    实际采用的是逐级缓存的设计减少 ARP 请求。发送接口先查询本地的 ARP 表，如果本地没有数据，然后广播 ARP 查询。这个时候如果交换机中有数据，那么查询交换机的 ARP 表；如果交换机中没有数据，才去广播消息给其他接口。注意，ARP 表是一种缓存，也要考虑缓存的设计。通常缓存的设计要考虑缓存的失效时间、更新策略、数据结构等。

## 网络编程

### Socket

    Socket 对象负责提供通信能力，并处理底层的 TCP 连接/UDP 连接。对服务端而言，每一个客户端接入，就会形成一个和客户端对应的 Socket 对象，如果服务器要读取客户端发送的信息，或者向客户端发送信息，就需要通过这个客户端 Socket 对象。
    从另一个角度去分析，Socket 还是一种文件，准确来说是一种双向管道文件。
    服务端（监听）Socket 里面存的是所有客户端 Socket 文件的文件描述符。
    当一个客户端连接到服务端的时候，操作系统就会创建一个客户端 Socket 的文件。然后操作系统将这个文件的文件描述符写入服务端程序创建的服务端 Socket 文件中。服务端 Socket 文件，是一个管道文件。如果读取这个文件的内容，就相当于从管道中取走了一个客户端文件描述符。
    客户端 Socket 是一个双向管道，操作系统将客户端传来的数据写入这个管道，也将线程写入管道的数据发送到客户端。

#### 服务端 Socket 的绑定

    服务端监听端口的本质，是将服务端 Socket 文件和端口绑定，这个操作也称为 bind。
    有时候我们不仅仅绑定端口，还需要绑定 IP 地址。这是因为有时候我们只想允许指定 IP 访问我们的服务端程序。

### I/O 多路复用技术

    对于一个服务端程序，可以定期扫描服务端 Socket 文件的变更，来了解有哪些客户端想要连接进来。如果在服务端 Socket 文件中读取到一个客户端的文件描述符，就可以将这个文件描述符实例化成一个 Socket 对象。
    之后，服务端可以将这个 Socket 对象加入一个容器（集合），通过定期遍历所有的客户端 Socket 对象，查看背后 Socket 文件的状态，从而确定是否有新的数据从客户端传输过来。
    上述的过程，通过一个线程就可以响应多个客户端的连接，也被称作I/O 多路复用技术。

### 响应式（Reactive）

    在 I/O 多路复用技术中，服务端程序（线程）需要维护一个 Socket 的集合（可以是数组、链表等），然后定期遍历这个集合。这样的做法在客户端 Socket 较少的情况下没有问题，但是如果接入的客户端 Socket 较多，比如达到上万，那么每次轮询的开销都会很大。
    从响应式的角度去看 Socket 编程，应该是有某个观察者会观察到 Socket 文件状态的变化，从而通知处理线程响应。线程不再需要遍历 Socket 集合，而是等待观察程序的通知。

### epoll 为什么用红黑树？

    select 是一个主动模型，需要线程自己通过一个集合存放所有的 Socket，然后发生 I/O 变化的时候遍历。
    在 select 模型下，操作系统不知道哪个线程应该响应哪个事件，而是由线程自己去操作系统看有没有发生网络 I/O 事件，然后再遍历自己管理的所有 Socket，看看这些 Socket 有没有发生变化。
    
    poll 提供了更优质的编程接口，但是本质和 select 模型相同。
    因此千级并发以下的 I/O，可以考虑 select 和 poll，但是如果出现更大的并发量，就需要用 epoll 模型。
    
    epoll（注册+消息推送）模型在操作系统内核中提供了一个中间数据结构，这个中间数据结构会提供事件监听注册，以及快速判断消息关联到哪个线程的能力（红黑树实现）。
    因此在高并发 I/O 下，可以考虑 epoll 模型，它的速度更快，开销更小。

### I/O 的编程模型

  - BIO（Blocking I/O，阻塞 I/O），API 的设计会阻塞程序调用。
  - NIO （None Blocking I/O，非阻塞 IO），API 的设计不会阻塞程序的调用。
  - AIO（Asynchronous I/O， 异步 I/O），API 的设计会多创造一条时间线。能够将异步操作再同步回主时间线的操作，我们称作异步转同步，也叫作异步编程。
  - 在处理高并发的时候，一种常见的 I/O 多路复用模式就是由少量的线程处理大量的网络接收、发送工作。然后再由更多的线程，通常是一个线程池处理具体的业务工作。

## Web技术

### 统一资源定位符（URL）

  ![URL](https://github.com/gongluck/images/blob/main/URL.png)

  - Scheme 部分代表协议，不只有 https，还有 ftp、ssh 等。不同协议代表着不同类型的应用在提供资源。
  - Host 部分代表站点，DNS 主要作用就是根据 Host 查找 IP 地址。
  - Port 是端口，代表提供服务的应用。
  - Path 是路径，代表资源在服务中的路径。
  - Query 是查询条件，代表需要的是资源中的某一个部分。
  - Fragment 是二级查询条件，通常不在服务端响应，而是用于前端展示定位内容。

### DNS（Domain Name System，域名系统）

    DNS（Domain Name System，域名系统）是一个将域名和 IP 地址相互映射的分布式服务。

#### 根域名服务器

    DNS 本身是一个出色的分布式架构。
    位于最顶层的是根域名服务器（Root Name Server）。人们在全世界范围内搭建了多台根域名服务器，2016 年的统计数据中，全世界目前有 13 台 IPv4 根服务器，25 台 IPv6 根服务器。
    因为流量、防止单点故障、平衡地理分布等问题，根域名服务器只是一个目录，并不提供具体的数据。

#### 域名分级和数据分区

    顶部第一级是根 DNS 存储，存储的是顶级域的目录，被称作根 DNS 服务器；
    第二级是顶级域存储，存储的是二级域的目录，被称作顶级域 DNS 服务器（Top Level DNS，TLD）；
    最后一级是叶子节点，存储的是具体的 DNS 记录，也被称作权威 DNS 服务器。

#### DNS 查询过程

    当用户在浏览器中输入一个网址，就会触发 DNS 查询。
    这个时候在上述的 3 个层级中，还会增加本地 DNS 服务器层级。
    本地 DNS 服务器包括用户自己路由器中的 DNS 缓存、小区的 DNS 服务器、ISP 的 DNS 服务器等。
    浏览器会缓存 DNS，此外，操作系统、路由器、本地 DNS 服务器也会……
    因此，绝大多数情况，请求不会到达根 DNS 服务器。
    很多大型的应用，会把 DNS 解析作为一种负载均衡的手段。

### 内容分发网络（Content Dilivery Network，CDN）

    内容分发网络（Content Dilivery Network，CDN）是一个专门用来分发内容的分布式应用。
    CDN 构建在现有的互联网之上，通过在各地部署数据中心，让不同地域的用户可以就近获取内容。这里的内容通常指的是文件、图片、视频、声音、应用程序安装包等，它们具有一个显著的特征——无状态，或者说是静态的。
    在 CDN 的设计当中，CDN 实际上提供的是数据的缓存。而原始数据，则由服务的提供者提供。

    用户请求静态资源通常用自己的域名（防止跨域和一些安全问题）。为了让用户请求的是自己的网站，而使用的是 CDN 的服务，这里会使用 CNAME 让自己的域名作为 CDN 域名的一个别名。当请求到 CDN 服务的时候，会首先由 CDN 的 DNS 服务帮助用户选择一个最优的节点，这个 DNS 服务还充当了负载均衡的作用。接下来，用户开始向 CDN 节点请求资源。如果这个时候资源已经过期或者还没有在 CDN 节点上，就会从源站读取数据，这个步骤称为CDN 的回源。
    另一方面，CDN 上缓存的资源通常也会伴随失效时间的设置，当失效之后同样会触发回源。另一种情况是可以通过开放的 API 或者 CDN 管理后台直接删除缓存（让资源失效），这个操作结束后，同样会触发回源。

### HTTP 超文本传输协议

#### 请求响应和长连接

    HTTP 协议采用请求/返回模型。
    HTTP 的请求和响应都是文本，可以简单认为 HTTP 协议利用 TCP 协议传输文本。
    为了节省握手、挥手的时间。当浏览器发送一个请求到 Web 服务器的时候，Web 服务器内部就设置一个定时器。在一定范围的时间内，如果客户端继续发送请求，那么服务器就会重置定时器。如果在一定范围的时间内，服务器没有收到请求，就会将连接断开。这样既防止浪费握手、挥手的资源，同时又避免一个连接占用时间过长无法回收导致内存使用效率下降。这个能力可以利用 HTTP 协议头添加 Keep-Alive 进行配置。

#### HTTP 2.0 的多路复用

    在 HTTP 2.0 之后，增加了多路复用能力。
    请求、返回会被拆分成切片，然后混合传输。这样请求、返回之间就不会阻塞。
    对于一个 TCP 连接，在 HTTP 1.1 的 Keep-Alive 设计中，第二个请求，必须等待第一个请求返回。如果第一个请求阻塞了，那么后续所有的请求都会阻塞。
    而 HTTP 2.0 的多路复用，将请求返回都切分成小片，这样利用同一个连接，请求相当于并行的发出，互相之间不会有干扰。

#### HTTP 方法和 RestFul 架构

    在 RestFul 架构中，状态仅仅存在于服务端，前端无状态。状态（State）可以理解为业务的状态，这个状态是由服务端管理的。这个无状态和服务端目前倡导的无状态设计不冲突，现在服务端倡导的无状态设计指的是容器内的服务没有状态，状态全部存到合适的存储中去。所以 Restful 中的 State，是服务端状态。

    前端（浏览器、应用等）没有业务状态，却又要展示内容，因此前端拥有的是状态的表示，也就是 Representation。比如一个订单，状态存在服务端（数据库中），前端展示订单只需要部分信息，不需要全部信息。前端只需要展示数据，展示数据需要服务端提供。所以服务端提供的不是状态，而是状态的表示。

    前端没有状态，当用户想要改变订单状态的时候，比如支付，这个时候前端就向服务端提交表单，然后服务端触发状态的变化。这个过程我们称为转化（Transfer）。从这个角度来看，Restful 讲的是一套前端无状态、服务端管理状态，中间设计转化途径（请求、函数等）的架构方法。这个方法可以让前后端职责清晰，前端负责渲染，服务端负责业务。前端不需要业务状态，只需要展示。服务端除了关心状态，还要提供状态的转换接口。

  -  http url对外暴露
  
  ```http
  http(s)://域名:端口[/版本]/资源路径/变量
  ```

  - XML/JSON格式定义

      参数和返回结果使用XML/JSON格式化。

  - METHOD对应请求的行为

  | METHOD | 行为  |
  | :----: | :---: |
  |  GET   | 查询  |
  |  POST  | 增加  |
  |  PUT   | 更新  |
  | DELETE | 删除  |

  - 无状态

      客户端与服务端之间的交互在请求之间是无状态的，从客户端到服务端的每个请求都必须包含理解请求所必需的信息。

  -  幂等性

      多次重复请求时，接口能保证与预期相符的结果。

### 网络爬虫

    通常一个网站，会在自己根路径下的 robots.txt 中定义自己网页中哪些数据是可以用来爬取的。
    从理论上讲，如果想爬取一个网站的数据，应该先获取它根目录下的 robots.txt 文件，查阅文件内容，看要爬取的数据是否被允许。