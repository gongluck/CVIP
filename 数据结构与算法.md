# 数据结构与算法

- [数据结构与算法](#数据结构与算法)
  - [复杂度](#复杂度)
  - [数据结构和算法的优化](#数据结构和算法的优化)
  - [数组](#数组)
  - [线性表](#线性表)
  - [栈](#栈)
  - [队列](#队列)
  - [树](#树)
  - [哈希表](#哈希表)

## 复杂度

- 时间复杂度与代码的结构设计高度相关；空间复杂度与代码中数据结构的选择高度相关。
- 一个顺序结构的代码，复杂度是O(1)。
- 二分查找，或者更通用地说是采用分而治之的二分策略，复杂度都是O(logn)。
- 一个简单的for循环，复杂度是O(n)。
- 两个顺序执行的for循环，复杂度是O(n)+O(n)=O(2n)，其实也是O(n)。
- 两个嵌套的for循环，复杂度是O(n²)。

## 数据结构和算法的优化

- 在程序开发中，连接时间和空间的桥梁就是数据结构。对于一个开发任务，如果能找到一种高效的数据组织方式，采用合理的数据结构的话，那就可以实现时间复杂度的再次降低。同样的，这通常会增加数据的存储量，也就是增加了空间复杂度。
- 数据处理的基本操作只有3个，分别是增、删、查。其中，增和删又可以细分为在数据结构中间的增和删，以及在数据结构最后的增和删。区别就在于原数据的位置是否发生改变。查找又可以细分为按照位置条件的查找和按照数据数值特征的查找。几乎所有的数据处理，都是这些基本操作的组合和叠加。
- 优化方法论：
  - 第一步，暴力解法。在没有任何时间、空间约束下，完成代码任务的开发。
  - 第二步，无效操作处理。将代码中的无效计算、无效存储剔除，降低时间或空间复杂度。
  - 第三步，时空转换。设计合理数据结构，完成时间复杂度向空间复杂度的转移。

## 数组

- 数组时一种容器，可以用来存放若干个相同类型的数据元素。
- 数组在内存中是连续存放的，数组内的数据，可以通过索引值直接取出得到。
- 数组在存储数据时是按顺序存储的，并且存储数据的内存也是连续的，这就造成了它具有增删困难、查找容易的特点。
- 在最后若插入数据，则时间复杂度为O(1)；如果中间某处插入数据，则时间复杂度为O(n)。
- 删除对应位置，扫描全数组，时间复杂度为O(n)。
- 如果只需根据索引值进行一次查找，时间复杂度是O(1)。但是要在数组中查找一个数值满足指定条件的数据，则时间复杂度是O(n)。

## 线性表

- 线性表是n个数据元素的有限序列，最常用的是链式表达，通常也叫作线性链表或者链表。
- 在单链表中存储的数据元素也叫作结点，一个结点存储的就是一条数据记录。每个结点的结构包括两个部分：
  - 第一是具体的数据值；
  - 第二是指向下一个结点的指针。
- 在链表的最前面，通常会有个头指针用来指向第一个结点。对于链表的最后一个结点，由于在它之后没有下一个结点，因此它的指针是个空指针。
- 对于一个单向链表，让最后一个元素的指针指向第一个元素，就得到了循环链表。
- 把结点的结构进行改造，除了有指向下一个结点的指针以外，再增加一个指向上一个结点的指针。这样就得到了双向链表。
- 可以对双向链表和循环链表进行融合，就得到了双向循环链表。
- 链表在新增、删除数据都比较容易，可以在O(1)的时间复杂度内完成。但对于查找，不管是按照位置的查找还是按照数值条件的查找，都需要对全部数据进行遍历。这显然就是O(n)的时间复杂度。
- **虽然链表在新增和删除数据上有优势，但仔细思考就会发现，这个优势并不实用。这主要是因为，在新增数据时，通常会伴随一个查找的动作。**
- 如果数据的元素个数不确定，且需要经常进行数据的新增和删除时，那么链表会比较合适。如果数据元素大小确定，删除插入的操作并不多，那么数组可能更适合些。

## 栈

- 栈是一种特殊的线性表。栈与线性表的不同，体现在增和删的操作。
- 栈的数据结点必须后进先出。栈的数据新增操作只能在末端进行，不允许在栈的中间某个结点后新增数据。栈的数据删除操作也只能在末端进行，不允许在栈的中间某个结点后删除数据。
- 栈的数据新增和删除操作只能在这个线性表的表尾进行，即在线性表的基础上加了限制。
- 栈既然是线性表，那么它也包含了表头和表尾。不过在栈结构中，由于其操作的特殊性，会对表头和表尾的名字进行改造。表尾用来输入数据，通常也叫作栈顶（top）；相应地，表头就是栈底（bottom）。栈顶和栈底是用来表示这个栈的两个指针。跟线性表一样，栈也有顺序表示和链式表示，分别称作顺序栈和链栈。
- 对于链式栈来说，新增删除数据元素没有任何循环操作，其时间复杂度均为O(1)。对于查找操作，相对链表而言，链栈没有额外的改变，它也需要遍历整个栈来完成基于某些条件的数值查找。
- 不管是顺序栈还是链栈，数据的新增、删除、查找与线性表的操作原理极为相似，时间复杂度完全一样，都依赖当前位置的指针来进行数据对象的操作。区别仅仅在于新增和删除的对象，只能是栈顶的数据结点。

## 队列

- 队列是一种特殊的线性表，与线性表的不同之处也是体现在对数据的增和删的操作上。
- 队列的特点是先进先出，队列的数据新增操作只能在末端进行，不允许在队列的中间某个结点后新增数据。
- 与线性表、栈一样，队列也存在这两种存储方式，即顺序队列和链式队列。
- 顺序队列，依赖数组来实现，其中的数据在内存中也是顺序存储。而链式队列，则依赖链表来实现，其中的数据依赖每个结点的指针互联，在内存中并不是顺序存储。链式队列，实际上就是只能尾进头出的线性表的单链表。
- 队列从队头（front）删除元素，从队尾（rear）插入元素。
- 对于一个顺序队列的数组来说，会设置一个front指针来指向队头，并设置另一个rear指针指向队尾。不断进行插入删除操作时，头尾两个指针都会不断向后移动。
- 循环队列进行新增数据元素操作时，首先判断队列是否为满。如果不满，则可以将新元素赋值给队尾，然后让rear指针向后移动一个位置。如果已经排到队列最后的位置，则rear指针重新指向头部。
- 循环队列进行删除操作时，即出队列操作，需要判断队列是否为空，然后将队头元素赋值给返回值，front指针向后移一个位置。如果已经排到队列最后的位置，就把front指针重新指向到头部。
- 当循环队列为空时，有front指针和rear指针相等。而是满时，同样有front指针和rear指针相等。常用的方法是，设置一个标志变量flag来区别队列是空还是满。
- 链式队列就是一个单链表，同时增加了front指针和rear指针。链式队列和单链表一样，通常会增加一个头结点，并令front指针指向头结点。头结点不存储数据，只是用来辅助标识。
- 链式队列进行新增数据操作时，将新结点赋值给原队尾结点的后继。然后把新结点设置为队尾结点。
- 当链式队列进行删除数据操作时，实际删除的是头结点的后继结点。这是因为头结点仅仅用来标识队列，并不存储数据。因此，出队列的操作，就需要找到头结点的后继，这就是要删除的结点。接着，让头结点指向要删除结点的后继。
- 如果链式队列除去头结点外只剩一个元素，那么删除仅剩的一个元素后，rear指针就变成野指针了。这时候，需要让rear指针指向头结点。
- 对于队列的查找操作，不管是顺序还是链式，队列都没有额外的改变。跟线性表一样，它也需要遍历整个队列来完成基于某些条件的数值查找。因此时间复杂度也是O(n)。
- 在时间复杂度上，循环队列和链式队列的新增、删除操作都为O(1)。而在查找操作中，队列和线性表一样只能通过全局遍历的方式进行，也就是需要O(n)的时间复杂度。在空间性能方面，循环队列必须有一个固定的长度，因此存在存储元素数量和空间的浪费问题，而链式队列不存在这种问题，所以在空间上，链式队列更为灵活一些。
- 通常情况下，在可以确定队列长度最大值时，建议使用循环队列。无法确定队列长度时，应考虑使用链式队列。

## 树

- 树是由结点和边组成的，不存在环的一种数据结构。树满足递归定义的特性。
- 在二叉树中，每个结点最多有两个分支，即每个结点最多有两个子结点，分别称作左子结点和右子结点。
- 满二叉树，定义为只有最后一层无任何子结点，其他所有层上的所有结点都有两个子结点的二叉树。
- 完全二叉树，定义为除了最后一层以外，其他层的结点个数都达到最大，并且最后一层的叶子结点都靠左排列。
- 树的遍历的时间复杂度是O(n)。在指定位置的数据增删操作时间复杂度都是O(1)。
- 对于查找操作，如果是普通二叉树，则查找的时间复杂度和遍历一样，都是O(n)。如果是二叉查找树，则可以在O(logn)的时间复杂度内完成查找动作。

## 哈希表

- 哈希表的设计采用了函数映射的思想，将记录的存储位置与记录的关键字关联起来。这样的设计方式，能够快速定位到想要查找的记录，而且不需要与表中存在的记录的关键字比较后再来进行查找。
- 哈希表提供非常快速的插入-删除-查找操作，无论多少数据，插入和删除值需要接近常量的时间。在查找方面，哈希表的速度比树还要快，基本可以瞬间查找到想要的元素。
- 哈希表中的数据是没有顺序概念的，所以不能以一种固定的方式（比如从小到大）来遍历其中的元素。哈希表中的key是不允许重复的。