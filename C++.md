# C++

- [C++](#c)
	- [基础](#基础)
		- [编译过程](#编译过程)
		- [链接](#链接)
			- [二者的优缺点](#二者的优缺点)
		- [内存管理](#内存管理)
		- [堆和栈的区别](#堆和栈的区别)
		- [全局变量、局部变量、静态全局变量、静态局部变量的区别](#全局变量局部变量静态全局变量静态局部变量的区别)
		- [`i++`与`++i`](#i与i)
		- [不用中间变量，交换`a`和`b`的值](#不用中间变量交换a和b的值)
		- [`main`函数执行完之后还会执行其他语句吗？](#main函数执行完之后还会执行其他语句吗)
		- [宏参数的连接](#宏参数的连接)
		- [`const`和`#define`的特点和区别](#const和define的特点和区别)
		- [`const`的作用](#const的作用)
		- [`static`的作用](#static的作用)
		- [字节对齐](#字节对齐)
		- [`C++`中4种指针转化运算符](#c中4种指针转化运算符)
	- [内联函数](#内联函数)
		- [宏函数和内联函数](#宏函数和内联函数)
	- [友元](#友元)
	- [构造函数](#构造函数)
		- [构造函数放在`private`区](#构造函数放在private区)
	- [析构函数](#析构函数)
	- [虚函数](#虚函数)
		- [虚函数的实现](#虚函数的实现)
		- [虚析构函数](#虚析构函数)
		- [构造函数中调用虚函数](#构造函数中调用虚函数)
	- [模板](#模板)

## 基础

### 编译过程

编译（编译预处理、编译、优化），汇编，链接。

![编译过程](https://github.com/gongluck/images/blob/main/编译过程.png)

- 编译预处理：处理以 `#` 开头的指令；
- 编译、优化：将源码 `.cpp` 文件翻译成 `.s` 汇编代码；
- 汇编：将汇编代码 `.s` 翻译成机器指令 `.o` 文件；
- 链接：汇编程序生成的目标文件，即 `.o` 文件，并不会立即执行，因为可能会出现：`.cpp` 文件中的函数引用了另一个 `.cpp` 文件中定义的符号或者调用了某个库文件中的函数。那链接的目的就是将这些文件对应的目标文件连接成一个整体，从而生成可执行的程序 `.exe` 文件。

### 链接

- 静态链接：代码从其所在的静态链接库中拷贝到最终的可执行程序中，在该程序被执行时，这些代码会被装入到该进程的虚拟地址空间中。
- 动态链接：代码被放到动态链接库或共享对象的某个目标文件中，链接程序只是在最终的可执行程序中记录了共享对象的名字等一些信息。在程序执行时，动态链接库的全部内容会被映射到运行时相应进行的虚拟地址的空间。

#### 二者的优缺点

- 静态链接：浪费空间，每个可执行程序都会有目标文件的一个副本，这样如果目标文件进行了更新操作，就需要重新进行编译链接生成可执行程序（更新困难）；优点就是执行的时候运行速度快，因为可执行程序具备了程序运行的所有内容。
- 动态链接：节省内存、更新方便，但是动态链接是在程序运行时，每次执行都需要链接，相比静态链接会有一定的性能损失。

### 内存管理

`C++` 内存分区：栈、堆、全局/静态存储区、常量存储区、代码区。

- 栈：存放函数的局部变量、函数参数、返回地址等，由编译器自动分配和释放。
- 堆：动态申请的内存空间，就是由 malloc 分配的内存块，由程序员控制它的分配和释放，如果程序执行结束还没有释放，操作系统会自动回收。
- 全局区/静态存储区（`.bss` 段和 `.data` 段）：存放全局变量和静态变量，程序运行结束操作系统自动释放，在 `C` 语言中，未初始化的放在 `.bss` 段中，初始化的放在 `.data` 段中，`C++` 中不再区分了。
- 常量存储区（`.data` 段）：存放的是常量，不允许修改，程序运行结束自动释放。
- 代码区（`.text` 段）：存放代码，不允许修改，但可以执行。编译后的二进制文件存放在这里。

从操作系统的本身来讲，以上存储区在内存中的分布是如下形式(从低地址到高地址)：
`.text` 段 --> `.data` 段 --> `.bss` 段 --> 堆 --> `unused` --> 栈 --> `env`

### 堆和栈的区别

- 申请方式：栈是系统自动分配，堆是程序员主动申请。
- 申请后系统响应：分配栈空间，如果剩余空间大于申请空间则分配成功，否则分配失败栈溢出；申请堆空间，堆在内存中呈现的方式类似于链表（记录空闲地址空间的链表），在链表上寻找第一个大于申请空间的节点分配给程序，将该节点从链表中删除，大多数系统中该块空间的首地址存放的是本次分配空间的大小，便于释放，将该块空间上的剩余空间再次连接在空闲链表上。
栈在内存中是连续的一块空间（向低地址扩展）最大容量是系统预定好的，堆在内存中的空间（向高地址扩展）是不连续的。
- 申请效率：栈是有系统自动分配，申请效率高，但程序员无法控制；堆是由程序员主动申请，效率低，使用起来方便但是容易产生碎片。
- 存放的内容：栈中存放的是局部变量，函数的参数；堆中存放的内容由程序员控制。

### 全局变量、局部变量、静态全局变量、静态局部变量的区别

`C++` 变量根据定义的位置的不同的生命周期，具有不同的作用域，作用域可分为 `6` 种：全局作用域，局部作用域，语句作用域，类作用域，命名空间作用域和文件作用域。

- 全局变量：具有全局作用域。全局变量只需在一个源文件中定义，就可以作用于所有的源文件。当然，其他不包含全局变量定义的源文件需要用 `extern` 关键字再次声明这个全局变量。
- 静态全局变量：具有文件作用域。它与全局变量的区别在于如果程序包含多个文件的话，它作用于定义它的文件里，不能作用到其它文件里，即被 `static` 关键字修饰过的变量具有文件作用域。这样即使两个不同的源文件都定义了相同名字的静态全局变量，它们也是不同的变量。
- 局部变量：具有局部作用域。它是自动对象（`auto`），在程序运行期间不是一直存在，而是只在函数执行期间存在，函数的一次调用执行结束后，变量被撤销，其所占用的内存也被收回。
- 静态局部变量：具有局部作用域。它只被初始化一次，自从第一次被初始化直到程序运行结束都一直存在，它和全局变量的区别在于全局变量对所有的函数都是可见的，而静态局部变量只对定义自己的函数体始终可见。

从分配内存空间看，变量可以分为：

- 静态存储区：全局变量，静态局部变量，静态全局变量；
- 栈：局部变量。

静态变量和栈变量（存储在栈中的变量）、堆变量（存储在堆中的变量）的区别：

- 静态变量会被放在程序的静态数据存储区（`.data` 段）中（静态变量会自动初始化），这样可以在下一次调用的时候还可以保持原来的赋值。
- 而栈变量或堆变量不能保证在下一次调用的时候依然保持原来的值。

静态变量和全局变量的区别：

- 静态变量用 `static` 告知编译器，自己仅仅在变量的作用范围内可见。

### `i++`与`++i`

- 内建数据类型的情况，效率没有区别。
- **自定义数据类型的情况，`++i`效率更高。`++i`可以返回对象的引用，`i++`必须返回对象的值。**

### 不用中间变量，交换`a`和`b`的值

```C++
void swap(int& a, int& b)
{
    //1 可能产生数据溢出
    a = a + b;
    b = a - b;
    a = a - b;
    //2
    a ^= b;
    b ^= a;
    a ^= b;
}
```

### `main`函数执行完之后还会执行其他语句吗？

可以用`atexit()`函数注册程序正常终止时要被调用的函数，在`main`函数结束时，按注册时的顺序**反序**调用这些函数。

```C++
#include <stdlib.h>
int atexit(void (*)void);
```

### 宏参数的连接

```C++
// #把宏参数变成一个字符串
#define FUNC(a) #a
const char* str = FUNC(把宏参数变成一个字符串);//const char* str = "把宏参数变成一个字符串";

// ##把两个宏参数粘合在一起
#define FUNC(a, b) a##b
const char* str = FUNC("把两个宏参数", "粘合在一起");//const char* str = "把两个宏参数""粘合在一起";
```

### `const`和`#define`的特点和区别

- `#define`常量没有数据类型，生命周期止于编译期，它存在于程序的代码段。
- `const`常量有数据类型，存在于程序的数据段，并在堆栈中分配了空间。

### `const`的作用

- 定义**常量**，编译器可以对其进行数据**静态类型安全检查**。
- 修饰**函数引用类型形参**，节省临时对象的构造、复制和析构过程的消耗，避免引用对象被修改。
- 修饰**函数返回值**，避免返回值被直接修改。
- 修饰**类成员函数**，避免修改数据成员。

### `static`的作用

- **函数体中的静态变量**，在函数被调用的过程中维持值不变。
- **模块内的全局静态变量**，可以被模块内所有函数访问，但不能被其他模块访问。
- **模块内的静态函数**，只能被模块内的其他函数调用。

### 字节对齐

- 结构体变量的首地址能被其**最宽基本类型成员的大小和编译器默认对齐较小值**所整除。
- 结构体每个成员相对于结构体首地址的偏移量都是**成员大小和编译器默认对齐较小值**的整数倍。
- 结构体总大小为**结构体最宽基本类型成员大小和编译器默认对齐较小值**的整数倍。

### `C++`中4种指针转化运算符

- `const_cast`:特定情况下，将const限制解除。
- `dynamic_cast`:可以在运行时将一个指向派生类的基类指针还原成原来的派生类指针。
- `reinterpret_cast`:指针间强行转化。
- `static_cast`:安全类型转化，转换定义了相关构造函数、类型转换函数或者有继承关系的类，或者将数域宽度大的类型转换到较小的类型。

## 内联函数

### 宏函数和内联函数

- 宏函数使用预处理器实现，没有参数压栈、代码生成等操作，效率高。但是只是简单的文本替换，没有参数有效性检测和类型检查，返回值也不能被强制转换为合适的类型。
- 内联函数在编译时展开，可以直接镶嵌到目标代码中。内联函数是函数，可以完成类型检查功能。

## 友元

- 相同`class`的各个`objects`互为友元

## 构造函数

### 构造函数放在`private`区

```C++
class A
{
public:
	static A& getInstance();
private:
	A();
	A(const A& rhs);
}
A& A::getInstance()
{
	static A a;
	return a;
}
```

## 析构函数

## 虚函数

### 虚函数的实现

```C++
#include <iostream>

class A
{
public:virtual void AA() {}
};
class B
{
public:virtual void BB() {}
};
class C : public A
{
public:virtual void CC() {}
};
class D : public A, public B
{
	virtual void DD() {}
};
class E : public D
{
	virtual void EE() {}
};
class F : public A, public E
{
	virtual void FF() {}
};
int main()
{
	A a; B b; C c; D d; E e; F f;
	return 0;
}
```

![C++虚函数表](https://github.com/gongluck/images/blob/main/C++虚函数表.png)

- 如果类中有虚函数，编译器会至少为这个类分配一个成员指针指向一张虚函数表，表中每一项指向一个虚函数地址。
- 多重继承情况下，为每个含有虚函数的基类分配一个虚表指针。
- 每个派生类的虚函数表继承它各个基类的虚函数表。
- **如果派生类覆盖了基类对应的一个虚函数，则派生类的虚函数表的该项指向重载后的虚函数。**
- 在类对象的内存布局中，首先是该类的虚函数表指针，然后才是对象数据。
- 在通过对象指针调用一个虚函数时，编译器生成的代码将先获取对象类的虚函数表指针，然后调用虚函数表中对应的一项。
- 如果派生类自身新增虚函数的话，那么这个函数地址会被添加到复制基类的虚函表最后一个位置中，如果是多继承的情况下，会被添加到继承顺序最先继承的基类虚函数表中。

### 虚析构函数

- 只有**当一个类被用来作为基类时**，才会把析构函数写成虚析构函数，以按正确完整的顺序调用基类和派生类的析构函数。
- 基类的析构函数声明为虚函数，所以子类的析构函数也是虚函数，即使子类实例被当作基类来使用，虚函数表中指向的是具体子类的析构函数。

### 构造函数中调用虚函数

```C++
#include<iostream>

class A
{
public:
	A()
	{ 
		func();
	}
	virtual void func() 
	{
		std::cout << "A";
	}
};
class B : public A
{
public:
	B()
	{ 
		func();
	};
	virtual void func()
	{
		std::cout << "B";
	}
};
int main(int argc, char* argv[])
{
	A* p = new B();//输出AB
	p->func();//输出B
	return 0;
}
```

- **基类的构造函数在派生类构造函数之前执行，当基类构造函数运行时，派生类数据成员还没有被初始化。**
- 在构造子类时调用父类的构造函数，而父类的构造函数中又调用了虚成员函数，这个虚成员函数即使被子类重写，也**不允许发生多态的行为**。所以使用的是**静态绑定**，调用了当前构造的父类的函数。

## 模板

- 不当地使用模板会导致代码膨胀，严重影响程序运行效率，**应该把模板与参数无关的代码分离出来**。
- 当模板需要对某些类型进行特别处理时，使用**特化**。
