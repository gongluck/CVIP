# 查找算法

- [查找算法](#查找算法)
  - [二分查找](#二分查找)
  - [广度优先搜索](#广度优先搜索)
  - [深度优先搜索](#深度优先搜索)
  - [BF 算法](#bf-算法)
  - [RK 算法](#rk-算法)
  - [BM 算法](#bm-算法)
  - [KMP 算法](#kmp-算法)
  - [Trie 树](#trie-树)
  - [贪心算法](#贪心算法)
  - [分治算法](#分治算法)
  - [回溯](#回溯)
  - [动态规划](#动态规划)

## 二分查找

![二分查找](https://github.com/gongluck/images/blob/main/data_structure_and_algorithm/search/binary_search.png)

- 二分查找针对的是一个有序的数据集合，每次都通过跟区间的中间元素对比，将待查找的区间缩小为之前的一半，直到找到要查找的元素，或者区间被缩小为 0。
- 二分查找是时间复杂度为 O(logn)的算法。
- 二分查找依赖的是顺序表结构，查找针对的是有序数据，而数组为了支持随机访问的特性，要求内存空间连续，对内存的要求比较苛刻。
- 二分查找只能用在插入、删除操作不频繁，一次排序多次查找的场景中。

## 广度优先搜索

![广度优先搜索](https://github.com/gongluck/images/blob/main/data_structure_and_algorithm/search/breadth_first_search.png)

## 深度优先搜索

## BF 算法

- BF 算法中文叫作暴力匹配算法，也叫朴素匹配算法。

## RK 算法

- 通过哈希算法对主串中的 n-m+1 个子串分别求哈希值，然后逐个与模式串的哈希值比较大小。如果某个子串的哈希值与模式串相等，那就说明对应的子串和模式串匹配了。因为哈希值是一个数字，数字之间比较是否相等是非常快速的，所以模式串和子串比较的效率就提高了。
- 模式串哈希值与每个子串哈希值之间的比较的时间复杂度是 O(1)，总共需要比较 n-m+1 个子串的哈希值，这部分的时间复杂度也是 O(n)。
- RK 算法整体的时间复杂度就是 O(n)。

## BM 算法

## KMP 算法

## Trie 树

![Trie树](https://github.com/gongluck/images/blob/main/data_structure_and_algorithm/search/trie_tree.png)

- Trie 树的本质，就是利用字符串之间的公共前缀，将重复的前缀合并在一起。
- 在一组字符串中，频繁地查询某些字符串，用 Trie 树会非常高效。构建 Trie 树的过程，需要扫描所有的字符串，时间复杂度是 O(n)。但一旦构建成功之后，后续的查询操作会非常高效。

## 贪心算法

## 分治算法

## 回溯

## 动态规划
