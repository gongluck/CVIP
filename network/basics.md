# 计算机网络

- [计算机网络](#计算机网络)
  - [网络编程](#网络编程)
    - [Socket](#socket)
      - [服务端 Socket 的绑定](#服务端-socket-的绑定)
      - [I/O 多路复用技术](#io-多路复用技术)
    - [响应式（Reactive）](#响应式reactive)
    - [epoll](#epoll)
    - [I/O 的编程模型](#io-的编程模型)
  - [Web 技术](#web-技术)
    - [统一资源定位符（URL）](#统一资源定位符url)
    - [DNS（Domain Name System，域名系统）](#dnsdomain-name-system域名系统)
      - [根域名服务器](#根域名服务器)
      - [域名分级和数据分区](#域名分级和数据分区)
      - [DNS 查询过程](#dns-查询过程)
    - [内容分发网络（Content Dilivery Network，CDN）](#内容分发网络content-dilivery-networkcdn)
    - [HTTP 超文本传输协议](#http-超文本传输协议)
      - [请求响应和长连接](#请求响应和长连接)
      - [HTTP 2.0 的多路复用](#http-20-的多路复用)
      - [HTTP 方法和 RestFul 架构](#http-方法和-restful-架构)
    - [网络爬虫](#网络爬虫)
    - [网络安全](#网络安全)
      - [加密技术](#加密技术)
        - [对称加密](#对称加密)
        - [非对称加密](#非对称加密)
      - [摘要算法](#摘要算法)
      - [签名](#签名)

## 网络编程

### Socket

- Socket 对象负责提供通信能力，并处理底层的 TCP 连接/ UDP 连接。对服务端而言，每一个客户端接入，就会形成一个和客户端对应的 Socket 对象，如果服务器要读取客户端发送的信息，或者向客户端发送信息，就需要通过这个客户端 Socket 对象。
- 从另一个角度去分析，Socket 还是一种文件，准确来说是一种双向管道文件。
- 服务端（监听）Socket 里面存的是所有客户端 Socket 文件的文件描述符。
- 当一个客户端连接到服务端的时候，操作系统就会创建一个客户端 Socket 的文件。然后操作系统将这个文件的文件描述符写入服务端程序创建的服务端 Socket 文件中。服务端 Socket 文件，是一个管道文件。如果读取这个文件的内容，就相当于从管道中取走了一个客户端文件描述符。
- 客户端 Socket 是一个双向管道，操作系统将客户端传来的数据写入这个管道，也将线程写入管道的数据发送到客户端。

#### 服务端 Socket 的绑定

- 服务端监听端口的本质，是将服务端 Socket 文件和端口绑定，这个操作也称为 bind。
- 有时候我们不仅仅绑定端口，还需要绑定 IP 地址。这是因为有时候我们只想允许指定 IP 访问我们的服务端程序。

#### I/O 多路复用技术

- 对于一个服务端程序，可以定期扫描服务端 Socket 文件的变更，来了解有哪些客户端想要连接进来。如果在服务端 Socket 文件中读取到一个客户端的文件描述符，就可以将这个文件描述符实例化成一个 Socket 对象。
- 之后，服务端可以将这个 Socket 对象加入一个容器（集合），通过定期遍历所有的客户端 Socket 对象，查看背后 Socket 文件的状态，从而确定是否有新的数据从客户端传输过来。
- 上述的过程，通过一个线程就可以响应多个客户端的连接，也被称作 I/O 多路复用技术。

### 响应式（Reactive）

- 在 I/O 多路复用技术中，服务端程序（线程）需要维护一个 Socket 的集合（可以是数组、链表等），然后定期遍历这个集合。这样的做法在客户端 Socket 较少的情况下没有问题，但是如果接入的客户端 Socket 较多，比如达到上万，那么每次轮询的开销都会很大。
- 从响应式的角度去看 Socket 编程，应该是有某个观察者会观察到 Socket 文件状态的变化，从而通知处理线程响应。线程不再需要遍历 Socket 集合，而是等待观察程序的通知。

### epoll

- select 是一个主动模型，需要线程自己通过一个集合存放所有的 Socket，然后发生 I/O 变化的时候遍历。
- 在 select 模型下，操作系统不知道哪个线程应该响应哪个事件，而是由线程自己去操作系统看有没有发生网络 I/O 事件，然后再遍历自己管理的所有 Socket，看看这些 Socket 有没有发生变化。
- poll 提供了更优质的编程接口，但是本质和 select 模型相同。
- 千级并发以下的 I/O，可以考虑 select 和 poll，但是如果出现更大的并发量，就需要用 epoll 模型。
- epoll（注册+消息推送）模型在操作系统内核中提供了一个中间数据结构，这个中间数据结构会提供事件监听注册，以及快速判断消息关联到哪个线程的能力（红黑树实现）。
- 在高并发 I/O 下，可以考虑 epoll 模型，它的速度更快，开销更小。

### I/O 的编程模型

- BIO（Blocking I/O，阻塞 I/O），API 的设计会阻塞程序调用。
- NIO （None Blocking I/O，非阻塞 IO），API 的设计不会阻塞程序的调用。
- AIO（Asynchronous I/O， 异步 I/O），API 的设计会多创造一条时间线。能够将异步操作再同步回主时间线的操作，我们称作异步转同步，也叫作异步编程。
- 在处理高并发的时候，一种常见的 I/O 多路复用模式就是由少量的线程处理大量的网络接收、发送工作。然后再由更多的线程，通常是一个线程池处理具体的业务工作。

## Web 技术

### 统一资源定位符（URL）

![URL](https://github.com/gongluck/images/blob/main/network/web/url.png)

- Scheme 部分代表协议，不只有 https，还有 ftp、ssh 等。不同协议代表着不同类型的应用在提供资源。
- Host 部分代表站点，DNS 主要作用就是根据 Host 查找 IP 地址。
- Port 是端口，代表提供服务的应用。
- Path 是路径，代表资源在服务中的路径。
- Query 是查询条件，代表需要的是资源中的某一个部分。
- Fragment 是二级查询条件，通常不在服务端响应，而是用于前端展示定位内容。

### DNS（Domain Name System，域名系统）

- DNS（Domain Name System，域名系统）是一个将域名和 IP 地址相互映射的分布式服务。

#### 根域名服务器

- DNS 本身是一个出色的分布式架构。
- 位于最顶层的是根域名服务器（Root Name Server）。人们在全世界范围内搭建了多台根域名服务器，2016 年的统计数据中，全世界目前有 13 台 IPv4 根服务器，25 台 IPv6 根服务器。
- 因为流量、防止单点故障、平衡地理分布等问题，根域名服务器只是一个目录，并不提供具体的数据。

#### 域名分级和数据分区

- 顶部第一级是根 DNS 存储，存储的是顶级域的目录，被称作根 DNS 服务器；
- 第二级是顶级域存储，存储的是二级域的目录，被称作顶级域 DNS 服务器（Top Level DNS，TLD）；
- 最后一级是叶子节点，存储的是具体的 DNS 记录，也被称作权威 DNS 服务器。

#### DNS 查询过程

- 当用户在浏览器中输入一个网址，就会触发 DNS 查询。
- 这个时候在上述的 3 个层级中，还会增加本地 DNS 服务器层级。
- 本地 DNS 服务器包括用户自己路由器中的 DNS 缓存、小区的 DNS 服务器、ISP 的 DNS 服务器等。
- 浏览器会缓存 DNS，此外，操作系统、路由器、本地 DNS 服务器也会……
- 因此，绝大多数情况，请求不会到达根 DNS 服务器。
- 很多大型的应用，会把 DNS 解析作为一种负载均衡的手段。

### 内容分发网络（Content Dilivery Network，CDN）

- 内容分发网络（Content Dilivery Network，CDN）是一个专门用来分发内容的分布式应用。
- CDN 构建在现有的互联网之上，通过在各地部署数据中心，让不同地域的用户可以就近获取内容。这里的内容通常指的是文件、图片、视频、声音、应用程序安装包等，它们具有一个显著的特征——无状态，或者说是静态的。
- 在 CDN 的设计当中，CDN 实际上提供的是数据的缓存。而原始数据，则由服务的提供者提供。
- 用户请求静态资源通常用自己的域名（防止跨域和一些安全问题）。为了让用户请求的是自己的网站，而使用的是 CDN 的服务，这里会使用 CNAME 让自己的域名作为 CDN 域名的一个别名。当请求到 CDN 服务的时候，会首先由 CDN 的 DNS 服务帮助用户选择一个最优的节点，这个 DNS 服务还充当了负载均衡的作用。接下来，用户开始向 CDN 节点请求资源。如果这个时候资源已经过期或者还没有在 CDN 节点上，就会从源站读取数据，这个步骤称为 CDN 的回源。
- 另一方面，CDN 上缓存的资源通常也会伴随失效时间的设置，当失效之后同样会触发回源。另一种情况是可以通过开放的 API 或者 CDN 管理后台直接删除缓存（让资源失效），这个操作结束后，同样会触发回源。

### HTTP 超文本传输协议

#### 请求响应和长连接

- HTTP 协议采用请求/返回模型。
- HTTP 的请求和响应都是文本，可以简单认为 HTTP 协议利用 TCP 协议传输文本。
- 为了节省握手、挥手的时间。当浏览器发送一个请求到 Web 服务器的时候，Web 服务器内部就设置一个定时器。在一定范围的时间内，如果客户端继续发送请求，那么服务器就会重置定时器。如果在一定范围的时间内，服务器没有收到请求，就会将连接断开。这样既防止浪费握手、挥手的资源，同时又避免一个连接占用时间过长无法回收导致内存使用效率下降。这个能力可以利用 HTTP 协议头添加 Keep-Alive 进行配置。

#### HTTP 2.0 的多路复用

- 在 HTTP 2.0 之后，增加了多路复用能力。
- 请求、返回会被拆分成切片，然后混合传输。这样请求、返回之间就不会阻塞。
- 对于一个 TCP 连接，在 HTTP 1.1 的 Keep-Alive 设计中，第二个请求，必须等待第一个请求返回。如果第一个请求阻塞了，那么后续所有的请求都会阻塞。
- 而 HTTP 2.0 的多路复用，将请求返回都切分成小片，这样利用同一个连接，请求相当于并行的发出，互相之间不会有干扰。

#### HTTP 方法和 RestFul 架构

- 在 RestFul 架构中，状态仅仅存在于服务端，前端无状态。状态（State）可以理解为业务的状态，这个状态是由服务端管理的。这个无状态和服务端目前倡导的无状态设计不冲突，现在服务端倡导的无状态设计指的是容器内的服务没有状态，状态全部存到合适的存储中去。所以 Restful 中的 State，是服务端状态。
- 前端（浏览器、应用等）没有业务状态，却又要展示内容，因此前端拥有的是状态的表示，也就是 Representation。比如一个订单，状态存在服务端（数据库中），前端展示订单只需要部分信息，不需要全部信息。前端只需要展示数据，展示数据需要服务端提供。所以服务端提供的不是状态，而是状态的表示。
- 前端没有状态，当用户想要改变订单状态的时候，比如支付，这个时候前端就向服务端提交表单，然后服务端触发状态的变化。这个过程我们称为转化（Transfer）。从这个角度来看，Restful 讲的是一套前端无状态、服务端管理状态，中间设计转化途径（请求、函数等）的架构方法。这个方法可以让前后端职责清晰，前端负责渲染，服务端负责业务。前端不需要业务状态，只需要展示。服务端除了关心状态，还要提供状态的转换接口。

### 网络爬虫

- 通常一个网站，会在自己根路径下的 robots.txt 中定义自己网页中哪些数据是可以用来爬取的。
- 从理论上讲，如果想爬取一个网站的数据，应该先获取它根目录下的 robots.txt 文件，查阅文件内容，看要爬取的数据是否被允许。

### 网络安全

#### 加密技术

##### 对称加密

- 双方加密解密都用相同密钥的算法，称为对称加密算法。
- 数据加密标准（DES）算法在 1976 年被美国国家标准局定为使用标准，后来被广泛传播。目前已经被证明可以被暴力破解。
- 高级加密标准（AES），这个加密法用 128 位密钥，并设计了更难破解的算法。

##### 非对称加密

- 公钥加密的数据必须用私钥解密，私钥加密的数据必须用公钥解密，称为非对称加密。
- 网站发送数据加密用私钥，用户用公钥解密。用户发送数据用公钥，网站用私钥解密。
- 目前最常见且广泛使用的非对称加密算法是 RSA 算法。

#### 摘要算法

- 通常对于一个给定的摘要算法，无论你的文章多大，有多少字节，最终生成摘要的字节数是固定的。
- 摘要是对原文的证明，从原文到摘要是一个不可逆的过程。

#### 签名

- 摘要的另一个非常重要的用途就是签名。
- 用私钥加密摘要，得到一个密文串，那么这个串就是数字签名（DIgital Sign）。
- 公钥解密（数字签名） == 原文摘要 == 摘要算法（原文） == 摘要
