# 动态共享库

- [动态共享库](#动态共享库)
  - [动态共享库原理](#动态共享库原理)
  - [动态共享库实现](#动态共享库实现)

## 动态共享库原理

![动态共享库原理](https://github.com/gongluck/images/blob/main/计算机基础/动态共享库原理.png)

## 动态共享库实现

![动态共享库实现](https://github.com/gongluck/images/blob/main/计算机基础/动态共享库实现.png)

- 对于所有动态链接共享库的程序来讲，虽然共享库用的都是同一段物理内存地址，但是在不同的应用程序里，它所在的虚拟内存地址是不同的。
- 动态代码库内部的变量和函数调用都很容易解决，只需要使用相对地址(Relative Address)就好了。各种指令中使用到的内存地址，给出的不是一个绝对的地址空间，而是一个相对于当前指令偏移量的内存地址。因为整个共享库是放在一段连续的虚拟内存地址中的，无论装载到哪一段地址，不同指令之间的相对地址都是不变的。
- 在编译的过程中，指定了一个`-fPIC`的参数。就是**Position Independent Code**的意思，要把这个编译成一个地址无关代码。
- 在动态链接对应的共享库，在共享库的`data section`里面，保存了一张全局偏移表(GOT, Global Offset Table)。虽然共享库的代码部分的物理内存是共享的，但是数据部分是各个动态链接它的应用程序里面各加载一份的。所有需要引用当前共享库外部的地址的指令，都会查询GOT，来找到当前运行程序的虚拟内存里的对应位置。而 GOT表里的数据，则是在加载一个个共享库的时候写进去的。
- 虽然不同的程序调用的同样的动态库，各自的内存地址是独立的，调用的又都是同一个动态库，但是不需要去修改动态库里面的代码所使用的地址，而是各个程序各自维护好自己的GOT，能够找到对应的动态库。
